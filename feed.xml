

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://blog.by-softcorp.com/</id>
  <title>BY Soft Tech Insights</title>
  <subtitle>BY-Soft의 기술 블로그는 코드의 힘을 통해 미래를 만들어가는 여정에서 우리가 직면한 도전과 성공의 순간들을 공유합니다. 여기에서는 현실 세계의 다양한 개발 과제들에 대한 해결책과 우리만의 기술적인 접근법을 자세하게 살펴볼 수 있습니다. 우리는 지식을 공유하고 협업을 통해 더 나은 개발자, 더 혁신적인 솔루션을 만들어가는 과정을 여러분과 함께 나누고자 합니다.</subtitle>
  <updated>2024-05-08T10:50:16+09:00</updated>
  <author>
    <name>BY-Soft</name>
    <uri>https://blog.by-softcorp.com/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://blog.by-softcorp.com/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://blog.by-softcorp.com/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator>
  <rights> © 2024 BY-Soft </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>ViewModel과 Model 유닛 테스트하기</title>
    <link href="https://blog.by-softcorp.com/posts/react-unit-test/" rel="alternate" type="text/html" title="ViewModel과 Model 유닛 테스트하기" />
    <published>2024-05-08T10:38:00+09:00</published>
  
    <updated>2024-05-08T10:38:00+09:00</updated>
  
    <id>https://blog.by-softcorp.com/posts/react-unit-test/</id>
    <content src="https://blog.by-softcorp.com/posts/react-unit-test/" />
    <author>
      <name>jessie.han</name>
    </author>

  
    
    <category term="typescript" />
    
    <category term="react" />
    
    <category term="frontend" />
    
  

  
    <summary>
      





      유닛 테스트란 어떤 단위의 모듈이 의도한 대로 동작하는지 확인하기 위한 과정입니다. 테스트 대상 단위가 정확하게 정해져있는 것은 아니지만, 이 단위의 크기를 작게 만들수록 테스트 코드를 작성하기가 쉽습니다. 데이터를 가져오는 로직과 그 데이터를 가공하는 로직, 그리고 가공한 데이터를 화면에 출력하는 로직이 하나의 컴포넌트에 전부 들어가있다고 생각해봅시다. 이 경우, 컴포넌트가 리턴하는 UI는 테스트해볼 수 있다고 하더라도, 컴포넌트 안에 얽혀있는 모든 함수들을 하나씩 뽑아내 테스트하기는 현실적으로 어렵습니다. 이러한 관점에서 MVVM 패턴은 유닛테스트를 진행하기 정말 좋은 패턴입니다. 모든 로직을 관리하던 컴포넌트에서 비즈니스 로직만을 따로 떼어내 함수 또는 클래스로 분리한 것이라고 보면 됩니다. 하나...
    </summary>
  

  </entry>

  
  <entry>
    <title>공통 기능을 가진 ViewModel 만들어 재사용하기</title>
    <link href="https://blog.by-softcorp.com/posts/reuse-viewmodel/" rel="alternate" type="text/html" title="공통 기능을 가진 ViewModel 만들어 재사용하기" />
    <published>2024-04-26T10:16:00+09:00</published>
  
    <updated>2024-04-26T10:16:00+09:00</updated>
  
    <id>https://blog.by-softcorp.com/posts/reuse-viewmodel/</id>
    <content src="https://blog.by-softcorp.com/posts/reuse-viewmodel/" />
    <author>
      <name>jessie.han</name>
    </author>

  
    
    <category term="typescript" />
    
    <category term="react" />
    
    <category term="frontend" />
    
  

  
    <summary>
      





      ViewModel을 재사용하기 위한 고찰

이전 블로그 글에서 MVVM 패턴을 적용했던 과정에 대해 남겨보았습니다. 그 이후로도 저는 여러가지 ViewModel과 Model을 구현해보았는데요, 매일 마주하는 코드인데도 불구하고 고쳐야 할 점이 매번 새롭게 보이고 있습니다. 쉽지 않은 내용인 만큼 아직도 MVVM 패턴에 익숙해지는 중인 것 같습니다. 최근 한달동안 가장 많이 고민 했던 내용이 MVVM이었던 터라 이번 글도 MVVM과 관련된 내용이지만, 오늘은 저번보다 조금! 더 발전한 내용을 가지고 와보았습니다.

처음 MVVM 패턴을 적용하면서는 “이렇게 작성하면 이런저런 부분에서 재사용이 가능하겠구나!” 하는 대략적인 생각을 했고, 몇가지의 ViewModel과 Model을 더 만들어보며 비슷하게 생긴...
    </summary>
  

  </entry>

  
  <entry>
    <title>신입 프론트엔드 개발자의 MVVM 패턴 적용기</title>
    <link href="https://blog.by-softcorp.com/posts/apply-mvvm-design/" rel="alternate" type="text/html" title="신입 프론트엔드 개발자의 MVVM 패턴 적용기" />
    <published>2024-03-26T10:47:00+09:00</published>
  
    <updated>2024-03-26T10:47:00+09:00</updated>
  
    <id>https://blog.by-softcorp.com/posts/apply-mvvm-design/</id>
    <content src="https://blog.by-softcorp.com/posts/apply-mvvm-design/" />
    <author>
      <name>jessie.han</name>
    </author>

  
    
    <category term="typescript" />
    
    <category term="react" />
    
    <category term="frontend" />
    
  

  
    <summary>
      





      MVVM 패턴은 디자인 패턴의 한 종류로, Model, View, ViewModel을 사용해 UI 관련 로직과 비즈니스 로직을 명확하게 분리합니다. 취업을 준비하던 시기에 진행했던 토이 프로젝트는 규모가 작아 이러한 패턴을 적용할 필요성을 느끼지 못했습니다. 그러나 프론트엔드 개발자로 일을 시작하고 사용자들이 사용할 실제 서비스를 제작하며, 코드의 유지보수성과 재사용성을 높이기 위해 MVVM 패턴을 적용해보는게 좋을것 같다는 코드리뷰 피드백을 받게 되었습니다. 신입 프론트엔드 개발자로써 한번도 써보지 않았던 MVVM 패턴을 어떻게 코드에 적용했는지, 또 리팩토링을 진행하며 어떤 부분을 고민했었는지 글을 통해 나눠보고자 합니다.

리팩토링 과정

초기 코드

interface DropdownListPro...
    </summary>
  

  </entry>

  
  <entry>
    <title>FastAPI와 SQLAlchemy 환경에서 Database Test</title>
    <link href="https://blog.by-softcorp.com/posts/fast-api-db-test/" rel="alternate" type="text/html" title="FastAPI와 SQLAlchemy 환경에서 Database Test" />
    <published>2022-06-26T15:32:00+09:00</published>
  
    <updated>2022-06-26T15:32:00+09:00</updated>
  
    <id>https://blog.by-softcorp.com/posts/fast-api-db-test/</id>
    <content src="https://blog.by-softcorp.com/posts/fast-api-db-test/" />
    <author>
      <name>alex.kim</name>
    </author>

  
    
    <category term="python" />
    
    <category term="backend" />
    
  

  
    <summary>
      





      FIRST 원칙

단위 테스트를 수행하는 데 있어 여러 가지 가이드가 있지만 일반적으로 적용하고 있는 FIRST 원칙은 다음과 같습니다.


  Fast
  Independent
  Repeatable
  Self-Validating
  Timely


하지만 22년 6월 기준 FastAPI와 SQLAlchemy에서 제공하는 공식문서상의 튜토리얼을 따라가면 2번째 항목인 Independent를 만족하지 못하는 현상이 발생합니다. 이는 매우 안타까운 상황이며, 많은 기술 블로그를 보아도 위와 같은 상황으로 고민하는 개발자들을 만나볼 수 있죠.
이 포스팅은 이런 문제에 대해 다른 Unit-Test lib에서와 같이 독립성을 보장하는 데이터베이스 환경을 구성하는 방향으로 잡아보았습니다.

Database E...
    </summary>
  

  </entry>

  
  <entry>
    <title>Python 열거형과 SQLAlchemy</title>
    <link href="https://blog.by-softcorp.com/posts/annotated-enum/" rel="alternate" type="text/html" title="Python 열거형과 SQLAlchemy" />
    <published>2022-05-15T09:00:00+09:00</published>
  
    <updated>2022-05-15T09:00:00+09:00</updated>
  
    <id>https://blog.by-softcorp.com/posts/annotated-enum/</id>
    <content src="https://blog.by-softcorp.com/posts/annotated-enum/" />
    <author>
      <name>alex.kim</name>
    </author>

  
    
    <category term="python" />
    
    <category term="structure" />
    
  

  
    <summary>
      





      Python의 Enum Type

기본적으로 Python의 열거형은 여러 이름을 같은 값에 대해 별칭으로 사용합니다.
예를 들면 열거형의 멤버에 동일한 값을 가진 A와 B가 정의되어 있다면 B는 A의 별칭입니다.

class Shape(Enum):
    SQUARE = 2
    DIAMOND = 1
    CIRCLE = 3
    ALIAS_FOR_SQUARE = 2


위 Shape를 예로 들어보면 ALIAS_FOR_SQUARE는 SQUARE의 별칭으로 SQUARE, ALIAS_FOR_SQUARE 중 어느 것을 조회해도 2(SQUARE)를 반환하게 됩니다.

&amp;gt;&amp;gt;&amp;gt; Shape.SQUARE
&amp;lt;Shape.SQUARE: 2&amp;gt;
&amp;gt;&amp;gt;&amp;gt; Shape.ALIAS_FO...
    </summary>
  

  </entry>

</feed>


