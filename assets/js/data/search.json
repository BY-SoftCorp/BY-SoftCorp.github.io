[
  
  {
    "title": "FastAPI와 SQLAlchemy 환경에서 Database Test",
    "url": "/posts/fast-api-db-test/",
    "categories": "python, backend",
    "tags": "fastapi, sqlalchemy, unittest",
    "date": "2022-06-26 15:32:00 +0900",
    





    
    "snippet": "FIRST 원칙단위 테스트를 수행하는 데 있어 여러 가지 가이드가 있지만 일반적으로 적용하고 있는 FIRST 원칙은 다음과 같습니다.  Fast  Independent  Repeatable  Self-Validating  Timely하지만 22년 6월 기준 FastAPI와 SQLAlchemy에서 제공하는 공식문서상의 튜토리얼을 따라가면 2번째 항목인 ...",
    "content": "FIRST 원칙단위 테스트를 수행하는 데 있어 여러 가지 가이드가 있지만 일반적으로 적용하고 있는 FIRST 원칙은 다음과 같습니다.  Fast  Independent  Repeatable  Self-Validating  Timely하지만 22년 6월 기준 FastAPI와 SQLAlchemy에서 제공하는 공식문서상의 튜토리얼을 따라가면 2번째 항목인 Independent를 만족하지 못하는 현상이 발생합니다. 이는 매우 안타까운 상황이며, 많은 기술 블로그를 보아도 위와 같은 상황으로 고민하는 개발자들을 만나볼 수 있죠.이 포스팅은 이런 문제에 대해 다른 Unit-Test lib에서와 같이 독립성을 보장하는 데이터베이스 환경을 구성하는 방향으로 잡아보았습니다.Database EngineFastAPI에서 제공하는 공식 문서대로 테스트 환경에서 Database를 이용해야 할 때 sqlite:///:memory:와 같이 SQLite를 이용하라고 권고하고 있습니다.이와 같은 방식은 대부분 문제가 발생하지 않지만, 실제 서비스가 sqlite로 구성되어있지 않다면 몇몇 field 등에서는 실제로 구성된 스키마와 다른 문제 때문에 완벽한 테스트를 보장할 수 없다는 문제가 있습니다.Test가 성공적으로 수행되고 난 후의 코드는 실제상황에서 안정적인 동작을 보장해야 하는데 MySQL을 사용하는 우리 서비스에서 SQLite를 이용한 Database 테스트를 수행할 수는 없었습니다.또한 실제 환경과 동일한 환경을 구성하기 위한다는 명분으로 아무리 개발 서버라고 하더라도 Test를 그곳에서 실행할 수는 없다는 판단과 Test의 Performance를 위해 로컬 환경에 MySQL 서버를 생성하는 쪽으로 방향을 잡고 Docker를 이용해 MySQL 서버를 띄워보았습니다.docker run --platform linux/amd64 -p 3306:3306 --name test_db -e MYSQL_ROOT_PASSWORD=password -e MYSQL_DATABASE=test_db -e MYSQL_PASSWORD=password --restart=unless-stopped -d mysqlTest 환경변수 설정Test가 동작하는 환경이라고 하더라도 기본적으로 실제 환경과 거의 동일한 환경에서 작동되어야 합니다.하지만 Test 환경에서만 적용되어야 하는 환경변수에 대한 Mocking이 필요한데 pytest에서 제공해주는 pytest.ini를 통해 다음과 같이 Database의 환경변수 위주로 재구성하였습니다. 위 Section에서도 설명했듯이 실제 Database에서 테스트를 진행할 수는 없으니까 말이죠.[pytest]env =    APP_ENV=test    DATABASE_HOST=localhost    DATABASE_USER=root    DATABASE_PASSWORD=password    DATABASE_NAME=test_dbDatabase Engine 생성아이메디신 에서는 Database 접근에 대해서 SQLAlchemy라는 객체 형식으로 관리하고 있습니다. SQLAlchemy는 Python 환경에서 ORM을 제공해주는 라이브러리로, 상당히 많은 Python 기반의 프로젝트에서 사용하고 있을 정도로 범용성이 높다고 볼 수 있습니다. FastAPI의 공식 문서에서도 SQLAlchemy를 다루고 있기도 하죠.class Settings(BaseSettings):    ...    @property    def database_url(self):        return f'mysql+pymysql://{self.DATABASE_USER}:{self.DATABASE_PASSWORD}@' \\               f'{self.DATABASE_HOST}:{self.DATABASE_PORT}/{self.DATABASE_NAME}?charset=utf8mb4'...class SQLAlchemy:    @classmethod    def create_engine(cls):        setting_dict = dict(            DATABASE_URL=settings.database_url,            DATABASE_POOL_RECYCLE=settings.DATABASE_POOL_RECYCLE,            DATABASE_ECHO=settings.DATABASE_ECHO,        )        return SQLAlchemy(**setting_dict)    ......database = SQLAlchemy.create_engine()Settings 객체를 보면 database_url을 조합, 리턴 해주는 property에서 DATABASE_HOST, DATABASE_USER… 등의 환경변수가 있는데, 만약 구동되는 환경이 Test 환경이라면 앞서 pytest.ini에서 설정해준 환경변수가 적용되어 local.database를 바라보게 될 것입니다.conftest.pypytest에서는 테스트 환경에 필요한 fixture, plugin, module 등을 관리하기 위해 conftest.py라는 파일을 사용할 것을 권하고 있습니다. 이는 단위테스트가 동작할 때 필요한 given을 미리 정의 해놓은 파일로, 일종의 setUp 함수와 비슷하지만 동일하지는 않죠.또한 모든 단위테스트에서 단 하나의 session을 호출해야 테스트가 종료되었을 때 후속 작업을 일괄되게 처리할 수 있다는 점과 한 번의 단위테스트 내에서 몇 단계에 걸쳐 fixture를 호출해도 멱등성을 보장한다는 특징은 conftest를 사용해야 하는 이유이기도 하죠.이제 conftest에 Test 용 Database 세션을 관리하도록 해보겠습니다.from app.app_core.databases.conn import database@fixture(scope='session', autouse=True)def db():    from sqlalchemy_utils import create_database, database_exists, drop_database    engine = database.engine    _db = {        'engine': engine,        'session': sessionmaker(autocommit=False, autoflush=False, bind=engine),    }    if database_exists(engine.url):        drop_database(engine.url)    create_database(engine.url)    try:        from alembic.config import Config as AlembicConfig        from alembic.command import upgrade as alembic_upgrade, downgrade as alembic_downgrade        from app.app_core.settings import settings        alembic_config = AlembicConfig()        alembic_config.set_main_option('sqlalchemy.url', settings.database_url)        alembic_config.set_main_option('script_location', 'revision')        alembic_upgrade(alembic_config, 'head')        yield _db    finally:        engine.dispose()fixture에 제공되는 매개변수 중 scope='session'을 통해 해당 fixture가 테스트가 유지되는 동안 같은 인스턴스를 반환하도록 설정하였습니다. 이는 테스트 건당 데이터베이스를 생성하는 건 테스트의 성능 저하와도 밀접한 연관이 있기 때문입니다. 또한 autouse=True 옵션을 주어 명시적으로 db라는 fixture를 호출하지 않아도 데이터베이스가 구성될 수 있도록 처리하였습니다.이제 db 인스턴스가 필요한 어느 곳에서든 def test_some(db):와 같은 방식으로 database에 접근할 수 있습니다.하지만 대부분의 코드에서는 database 객체에 직접 접근 하는 경우보단 하나의 session에 접근하는 게 일반적입니다. 따라서 session 객체 역시 fixture로 관리해야 할 필요성을 느낍니다.@fixturedef engine(db):    engine = db['engine']    connection = engine.connect()    transaction = connection.begin()    yield engine    transaction.rollback()@fixturedef session(db) -&gt; Session:    session = db['session']()    session.begin_nested()    yield session    session.rollback()    session.close()현재까지 아이메디신의 FastAPI 프로젝트는 engine을 직접 제어하지는 않지만, 추후 필요할지도 모른다는 생각에 session을 만들면서 함께 만들어 보았습니다.단위 테스트 내에서 반드시 conftest에 정의된 session fixture를 사용할 필요는 없지만, 앞서 설명한 것과 같이 테스트가 종료된 후 다른 테스트에 영향을 주지 않기 위해서 처리하는 session.rollback() 부분이 정상적으로 동작하기 위해선 session fixture를 사용할 것을 권합니다.# 호출할 때마다 다른 인스턴스 생성# session.commit(), session.close() 처리가 완료되기 전에 다른 session에서 접근 시# 값이 반영되어 있지 않은 문제가 있음# 또한 fixture에서 사용한 rollback() 처리가 동작하지 않음def test_some():session = next(database.session())...# 호출할 때마다 같은 인스턴스 생성# flush() 처리만 되어있어도 데이터베이스에 값이 반영된 것처럼 보임# 가장 중요한 rollback() 처리 한 번으로 다른 테스트 코드에 영향을 주지 않음def test_some(session):dependency_overridesFastAPI에서는 router 호출 시 Depends를 이용해 여러 곳에서 같은 함수를 호출하더라도 단 하나의 인스턴스를 이용할 수 있는 방식을 제공합니다. 일종의 Singleton 패턴과도 같은 방식이죠. 그리고 테스트 환경에서 이 의존성을 Mocking 할 수 있는 방법을 dependency_overrides라는 방식으로 제공해주고 있습니다.dependency_overrides를 반드시 사용해야 하는 이유는 실제 동작 하는 코드인 router에서는 conftest의 fixture를 가져올 수 없기 때문입니다.일반적으로 router 안에서 사용되는 database.session은 다음과 같은 방식으로 구현됩니다.@router.post(    '/id',    summary='아이디 찾기',    ...)async def post_id(        session: Session = Depends(database.session),):    ...만약 dependency_overrides를 정의해 놓지 않은 상황이라면 router를 호출할 때마다 다른 인스턴스의 session이 생성될 것이며, 다음과 같은 테스트 코드에서 그 동작을 신뢰성을 보장할 수 없습니다.def test_some(client, session, admin_user):    customized_package = CustomizePackagePrice(...)    session.add(customized_package)    url = PATH_PAYMENTS_V1_0 + f'/customize_price_package?packageId={customized_package.id}'    user = gen_admin_user    client.force_authenticate(user)    res = client.get(url)    ...@router.get(    '/customize_price_package',    ...)async def get_customize_package_price(        query: CustomizePackagePriceQuery = Depends(),        session: Session = Depends(database.session),):    ...    package_id = query.package_id    packages = list_customize_package_price(session, package_id, user)    # dependency_overrides설정이 되어있지 않다면 다른 인스턴스의 session으로 인해 not found 발생    return paginate(packages)따라서 단위 테스트 실행 시 반드시 dependency_overrides를 구현해 주어야 동작의 신뢰도를 높일 수 있으며 FastAPI에서 제공하는 공식 문서상 구현 방법은 다음과 같습니다.def override_get_db():    try:        db = TestingSessionLocal()        yield db    finally:        db.close()app.dependency_overrides[get_db] = override_get_db하지만 이 방식대로 구현하게 되면 단위 테스트 내에서 사용하는 session과 router에서 사용되는 session이 다른 인스턴스를 사용하게 되는 문제가 있습니다. 위에서 지적한 동일한 인스턴스에 대한 접근이 위배 되는 상황이 발생하며, 무엇보다 한 번의 테스트가 끝난 후 그와 관련된 데이터의 rollback 처리가 수월하지 않다는 문제가 있죠.이 문제를 해결하기 위해선 이전에 구성한 fixture를 dependency injection 해주어야 하는데 이런 방식을 구상해 보았습니다.app.dependency_overrides[engine.session] = session위 코드가 잘 동작한다면 훌륭하겠지만, 아주 커다란 문제가 있습니다. 바로 session이라는 fixture는 db라는 다른 fixture를 매개변수로 받고 있다는 점과 fixture는 일종의 @property라는 점이죠. 아마도 당신이 위 코드를 실행하면 다음과 같은 오류를 만나게 될 것입니다.'&lt;sqlalchemy.orm.session.Session object at 0x1145520d0&gt; is not a callable object'난관에 부딪힌 상황이었지만, 다행히도 lambda 키워드를 사용해 생각보다는 간단하게 문제를 해결할 수 있었습니다. 또한 아이메디신에서 현재까지 개발된 테스트 코드는 Depends를 이용하기 위해선 TestClient를 이용해 router를 호출하는 때 외에는 없으므로 dependency_overrides를 TestClient를 호출하는 fixture에서 설정해주도록 구성해보았습니다.@fixturedef client(session):    # lambda식을 이용해 function 형태로 inject    app.dependency_overrides[engine.session] = lambda: session    from tests.test_routes import get_client    return get_client()위와 같은 구성으로 test 코드와 router에서 하나의 인스턴스 session을 사용하게 되어 router 테스트에서 완벽한 테스트 결과를 기대할 수 있게 되었습니다.환경 구성의 누락 방지만약 당신이 구현하고 있는 프로젝트의 데이터베이스에 대한 접근제어가 strict 하지 않은 상황이고, 프로젝트를 다른 환경에서 clone 하여 작업을 하려던 중 pytest.ini를 구성하는 걸 잊은 상태라면 pytest 명령어를 입력하는 순간if database_exists(engine.url):    drop_database(engine.url)설정에 따라 실제 데이터 베이스에 모든 테이블이 삭제되는 현상이 발생할 것입니다. 이는 실제 서비스가 중단될지도 모르는 매우 위험한 상황을 내포하고 있죠.제가 생각하는 이상적인 접근제어라면 database 인스턴스는 VPC 안에서 private 공간에 위치해야 하고, 해당 프로젝트를 개발하고 있는 Engineer라고 하더라도 직접적으로 데이터베이스에 접근할 수 있어서는 안 됩니다.하지만 여러 가지 상황으로 위와 같은 환경 구성이 어려운 경우 다음과 같은 검증 식을 conftest.py 최상단에 추가 함으로써, 데이터베이스를 삭제하는 실수를 방지할 수 있을것입니다.assert settings.APP_ENV == 'test', 'test 환경에서만 test 가능, `pytest.ini` 확인 필!'마치며단위테스트는 프로젝트를 개발해 나감에 있어 아주 기본적이지만 매우 중요한 절차이기 때문에 다른 포스팅 보단 조금 더 심도 있게 다루어 보았습니다. 아마도 다른 주제로 또다시 단위 테스트에 대해서 포스팅을 작성할 것 같다는 생각이 들기도 하네요.또 다른 단위 테스트 주제로 만나 뵙기를 희망합니다 :)"
  },
  
  {
    "title": "Python 열거형과 SQLAlchemy",
    "url": "/posts/annotated-enum/",
    "categories": "python, structure",
    "tags": "enum, sqlalchemy",
    "date": "2022-05-15 09:00:00 +0900",
    





    
    "snippet": "Python의 Enum Type기본적으로 Python의 열거형은 여러 이름을 같은 값에 대해 별칭으로 사용합니다.예를 들면 열거형의 멤버에 동일한 값을 가진 A와 B가 정의되어 있다면 B는 A의 별칭입니다.class Shape(Enum):    SQUARE = 2    DIAMOND = 1    CIRCLE = 3    ALIAS_FOR_SQUARE ...",
    "content": "Python의 Enum Type기본적으로 Python의 열거형은 여러 이름을 같은 값에 대해 별칭으로 사용합니다.예를 들면 열거형의 멤버에 동일한 값을 가진 A와 B가 정의되어 있다면 B는 A의 별칭입니다.class Shape(Enum):    SQUARE = 2    DIAMOND = 1    CIRCLE = 3    ALIAS_FOR_SQUARE = 2위 Shape를 예로 들어보면 ALIAS_FOR_SQUARE는 SQUARE의 별칭으로 SQUARE, ALIAS_FOR_SQUARE 중 어느 것을 조회해도 2(SQUARE)를 반환하게 됩니다.&gt;&gt;&gt; Shape.SQUARE&lt;Shape.SQUARE: 2&gt;&gt;&gt;&gt; Shape.ALIAS_FOR_SQUARE&lt;Shape.SQUARE: 2&gt;&gt;&gt;&gt; Shape(2)&lt;Shape.SQUARE: 2&gt;API로 열거형을 전달할때 고민FastAPI는 router의 요소를 자동으로 문서화해 주는 기능이 있습니다. 이는 문서작성의 시간을 상당 부분 줄여주어 매우 편리한 기능이라고 생각하는데 Python 열거형에 대해 조금은 부족한 부분이 있죠.class RequestEmailAuthType(str, Enum):    JOIN = '1'    RESET_PASSWORD = '2'...class RequestEmailAuthIn(CamelModel):    request_type: RequestEmailAuthType = Field(title='요청 타입')위와 같은 열거형을 API 요청에서 필드로 받는다고 가정하면 redoc 문서는 아래와 같이 나오게 됩니다.이 문서에는 한 가지 큰 문제가 있습니다. 바로 \"1\"과\"2\"가 무엇을 뜻하는지 문서만 보아서는 알 수가 없다는 점이죠. 다행히도 이 문제는 조금 간단하게 해결할 수 있습니다. 바로 Python의 __doc__ 기능을 이용해서죠.class RequestEmailAuthType(str, Enum):    \"\"\"    1: 가입, 2: 비밀번호 초기화    \"\"\"    JOIN = '1'    RESET_PASSWORD = '2'이런 식으로 열거형에 __doc__항목을 추가해 주면 redoc은 아래와 같이 자동으로 각각의 값에 대한 설명을 만들어줍니다.SQLAlchemy와의 연동FastAPI에서 ORM 기능을 이용하기 위해선 SQLAlchemy라는 OpneSource를 이용합니다. 매우 잘 만들어진 OpenSource이지만 Database에 열거형의 타입을 넣을 때 열거형이 값(value)이 아닌 키(name)가 들어간다는 것입니다.키가 들어가는 건 나름 의미 있는 데이터가 들어가는 것이라 데이터 베이스의 값을 직접 열어볼 때 조금은 더 직감적일 수 있다는 장점이 있긴 하지만, 최근 개발 동향상 데이터베이스에 직접 접근해서 CRUD 작업을 하는 경우는 잘 없다 보니 저장되는 데이터의 용량을 줄이기 위해 위에서 언급했던 별칭을 이용해 보도록 하겠습니다.class RequestEmailAuthType(str, Enum):    JOIN = '1'    RESET_PASSWORD = '2'    J = '1'    R = '2'SQLAlchemy가 알아서 별칭만을 알아서 추려낸 후 데이터베이스의 키로 설정해 줄 수 있다면 더 이상 손볼게 없어지지만, 아쉽게도 위 코드만으로는 다음과 같은 스키마로 enum 필드가 생성됩니다.`request_type` enum('JOIN','RESET_PASSWORD','J','R') NOT NULL,J와 R로 데이터를 채울 수는 있지만 썩 만족스럽지 않습니다. 저장되는 데이터의 크기를 줄여보자는 의도와 상충되는 부분이 있고, 무엇보다 동일한 의미의 값이 중복되어 표시될 수도 있다는 점이 혼란을 야기할 수도 있을 것 같다는 판단입니다.SQLAlchemy에서 Enum을 처리하는 방식을 살펴보면 대략 아래와 같이 구성되어 있습니다.if len(enums) == 1 and hasattr(enums[0], \"__members__\"):    self.enum_class = enums[0]    _members = self.enum_class.__members__    aliases = [n for n, v in _members.items() if v.name != n]    if self._omit_aliases is NO_ARG and aliases:        util.warn_deprecated_20(            \"The provided enum %s contains the aliases %s. The \"            \"``omit_aliases`` will default to ``True`` in SQLAlchemy \"            \"2.0. Specify a value to silence this warning.\"            % (self.enum_class.__name__, aliases)        )__members__를 통해 Enum 필드에 들어갈 항목들을 가져오는데, 아쉽게도 별칭만을 넣을 수 있는 옵션이 따로 없네요. 원키와 별칭의 순서를 바꾼 후 (별칭을 원키처럼 활용) _omit_aliases옵션을 줄까 생각해 보기도 하였지만, 별칭과 원키의 순서를 보장하고 싶다는 생각에 __members__를 조금 수정해 보기로 했습니다.class AliasOnlyEnumMeta(EnumMeta):    @property    def __members__(cls):        sp = super().__members__        items = sp.items()        alias_values = [v.value for n, v in items if v.name != n]        filtered = [n for n, v in items if (v.name == n and v.value not in alias_values) or v.name != n]        members = {k: v for k, v in items if k in filtered}        return membersclass RequestEmailAuthType(str, Enum, metaclass=AliasOnlyEnumMeta):    JOIN = '1'    RESET_PASSWORD = '2'    J = '1'    R = '2'Enum의 metaclass를 커스터마이징 한 AliasOnlyEnumMeta를 생성 후 __members__ property를 override 해서 별칭이 없는 키와 별칭이 있다면 별칭 만을 내려 주도록 해보았습니다.이제 이 코드를 적용해서 스키마를 생성해 보면 다음과 같이 Field가 생성되는 걸 확인할수 있죠.`request_type` enum('J','R') NOT NULL,Enum의 값으로 사용되는 키가 상당히 간결해진 느낌은 있지만, 이제 약자로 표현된 필드의 값이 무엇이 의미하는지 쉽게 해석이 힘들어지는 문제가 생기네요. SQLAlchemy에서 제공하는 comment키워드에 redoc에서 사용했던 것과 같이 __doc__ 이용해 해당 키의 의미를 설명으로 넣어보겠습니다.request_type = Column(Enum(RequestEmailAuthType), comment=RequestEmailAuthType.__doc__, nullable=False)이제 생성된 스키마를 보면 html과 일반 text의 차이 때문에 생각했던 것과는 조금 다른 형태의 comment가 붙어있는 걸 볼 수 있습니다.`request_type` enum('J','R') NOT NULL COMMENT '\\n        1: 가입, 2: 비밀번호 초기화\\n        ',어떻게 본다면 별문제 아닌 것 같지만 만들다 만 것 같은 느낌의 결과는 용납할 수 없습니다. comment키워드에 일일이 주석을 달아주는 것도 좋은 방법이 될 수 있지만, 수작업이 많아진다는 건 그만큼 실수의 가능성이 커진다는 것과 동일한 의미이기 때문에 이것을 자동으로 만들어 줄 수 있는 무언가를 만들어야겠다는 생각을 하고 다음과 같이 만들어 보았습니다.class AnnotatedEnum(Enum):    def __new__(cls, *args, **kwargs):        tu = cls.__bases__        if len(tu) == 1:            # plain Enum            t = object            pass        else:            t = tu[0]        obj = t.__new__(cls)        obj._value_ = args[0]        return obj    def __init__(self, _, desc: str = None):        self.desc = desc    @classmethod    @property    def comment(cls):        items = cls.__members__.items()        docs = [f'{n}: {v.desc}' for n, v in items]        return ', '.join(docs)class RequestEmailAuthType(str, AnnotatedEnum, metaclass=AliasOnlyEnumMeta):    \"\"\"    1: 가입, 2: 비밀번호 초기화    \"\"\"    JOIN = '1', '회원가입'    RESET_PASSWORD = '2', '비밀번호 초기화'    J = '1'    R = '2'...request_type = Column(Enum(RequestEmailAuthType), comment=RequestEmailAuthType.comment, nullable=False)Python 열거형에 설명을 달아줄 수 있는 AnnotatedEnum을 만들어 하위 클래스로 RequestEmailAuthType을 생성했습니다. 이제 JOIN = '1', '회원가입'이런 식으로 Tuple 형태로 열거형의 값을 지정할 수 있고, 두 번째 인자는 desc에 자동으로 매핑 되도록 만들어주었고, 이런 식의 구조는 다음과 같은 장점을 가질 수 있습니다.  키, 값, 설명을 한 줄로 처리를 해서 보다 직관적으로 해석이 가능하다.  키가 새로 생기거나 삭제될 때 __doc__처리의 누락을 최소화할 수 있다.위 방식으로 만들어낸 스키마를 보면 아래와 같이 좀 더 깔끔한 설명을 남길 수 있습니다.`request_type` enum('J','R') NOT NULL COMMENT 'J: 회원가입, R: 비밀번호 초기화',redoc에서도 Annotation을 사용할 수 없을까?키와 값, 그리고 설명을 한 줄로 관리할 수 있게 만들었다면 이를 다른 곳에서도 활용할 수 있는 게 더 좋겠다는 생각이 들어 앞서 만든 AliasOnlyEnumMeta클래스를 생성할 때에 몇 가지 수정사항을 넣어 열거형의 __doc__을 자동으로 만들어 주는 기능을 넣어봤습니다.redoc은 html 태그를 지원하다 보니 키와 값에 대한 설명에 약간의 강조 처리도 함께 적용시켜보았죠.class AliasOnlyEnumMeta(EnumMeta):    def __new__(metacls, cls, bases, classdict, **kwargs):        obj = super(AliasOnlyEnumMeta, metacls).__new__(metacls, cls, bases, classdict, **kwargs)        members = obj.__members__        _desc_list = [            f'&lt;em&gt;{v.value}&lt;/em&gt; : &lt;strong&gt;{v.desc or \"-\"}&lt;/strong&gt;'            for _, v in members.items() if hasattr(v, 'desc')        ]        obj.__doc__ = ', '.join(_desc_list)        return obj위 코드를 이용해 redoc 문서를 보면 아래와 같이 강조되는 항목들이 생겨났습니다.처음보다 훨씬 보기 좋은 문서가 만들어졌습니다. 또한 열거형에 개발자가 서술한 __doc__을 그대로 유지하면서 메모리상의 __doc__만을 변경처리하여, 열거형의 Overview를 그대로 유지하면서 API / Database의 설명만을 자동으로 만들어 주는 형식이라 여러 가지로 효율성이 증대되는 방식을 만들어 낸 것 같습니다."
  },
  
  {
    "title": "FastAPI 유효성 검사",
    "url": "/posts/fast-api-validator/",
    "categories": "python, backend",
    "tags": "pydantic, validate, fastapi",
    "date": "2022-04-25 09:00:00 +0900",
    





    
    "snippet": "Request Body ValidateAPI 요청을 받으면 최소한으로 수행해야 하는 유효성 검사가 있습니다. 보안의 가장 기본인 SQL Injection 공격 이외에도 전달받은 데이터가 필요로 하는 최소한의 규칙 등이 있습니다.password를 예로 들자면 대소문자, 숫자, 특수문자를 포함해 최소 8에서 최대 20자리까지의 텍스트를 만족한다던가 혹은 ...",
    "content": "Request Body ValidateAPI 요청을 받으면 최소한으로 수행해야 하는 유효성 검사가 있습니다. 보안의 가장 기본인 SQL Injection 공격 이외에도 전달받은 데이터가 필요로 하는 최소한의 규칙 등이 있습니다.password를 예로 들자면 대소문자, 숫자, 특수문자를 포함해 최소 8에서 최대 20자리까지의 텍스트를 만족한다던가 혹은 전화번호는 숫자와 +- 등으로만 구성이 되어있는지 판단할 경우가 생기기 마련이죠.FastAPI 에서는 pydantic 이라는 Opensource 를 통해서 검증할 수가 있습니다.BaseModelpydantic 에서 제공하는 BaseModel과 Field를 이용하면 기본적인 유효성 검증을 손쉽게 처리할 수 있으며, 직접 유효성 검증을 하는 코드를 삽입하는 것 보다 훨씬 직관적이고 간편하게 사용할 수 있는 장점이 있습니다.from pydantic import BaseModelclass ModelIn(BaseModel):    password: str = Field(title='비밀번호', regex='^(?=.*[a-zA-Z])(?=.*[!@#$%^*+=-])(?=.*[0-9]).{8,20}$')    id: Optional[int] = Field(title='ID', default=None, ge=0)    class Config:        orm_mode = True위 예시는 password의 경우 대소문자와 숫자 그리고 특수문자를 포함한 8~20자리의 비밀번호를 허용, id는 null 혹은 0보다 큰 숫자만 허용한다는 유효성 검증의 예시입니다.@validatorField의 매개변수로 사용하는 gt, lt, min_length… 등만으로도 상당수의 유효성 검사를 만족할 수는 있지만, 사용자 정의 유효성 검사 및 개체 간의 복잡한 관계는 @ decorator를 통해 수행할 수 있습니다.class UserModel(BaseModel):    name: str = Field()    email: str = Field()    password: str = Field()    @validator('name')    def name_must_contain_space(cls, v):        if ' ' not in v:            raise ValueError('must contain a space')        return v위 코드는 변수 name에 대한 customized validator로 @validator({필드명}) 으로 처리 할 수 있습니다. 이때 필드명은 복수로 설정할 수 있으며 예시는 다음과 같습니다.@validator('email', 'password')def decrypt_fields(cls, raw):    ...    return@root_validator필드별 유효성 검증 외에도 요청받은 전체 모델의 유효성 검증을 해야 하는 경우도 필요합니다.예를 들면 복수의 리스트를 전달받았을 때 전체 항목에서 중복된 값이 존재하는지 여부를 판별하는데 쓰일 수도 있죠.class OrganizationModelIn(BaseModel):    industries: List[IndustryModelIn] = Field()    ...    @root_validator    def duplicate_not_allowed(cls, values):        industries = values.get('industries')        ids = [industry.id for industry in industries]        id_set = set(ids)        if len(id_set) != len(ids):            raise ValueError('industry id`s duplicate not allowed')        return valuesE2EE (End to End Encryption)패스워드나 기타 식별데이터는 HTTPS 프로토콜을 사용한다고 하더라도 암호화를 거쳐 종단 간에 통신이 이루어져야 합니다.위에서 password 필드에 정규식 ^(?=.*[a-zA-Z])(?=.*[!@#$%^*+=-])(?=.*[0-9]).{8,20}$을 넣었지만, 암호화된 필드 값으로는 애초에 정규식을 판별할 수 없다는 문제가 있으며,이에 pydantic에서는 validator decorator에 pre=키워드를 이용해 validate 함수를 먼저 호출한 후 필드에 적용된 정규식을 검사할 수 있도록 제공하고 있습니다.@validator('email', 'password', pre=True)def decrypt_fields(cls, raw):    from app.core.utils.crypto import rsa    try:        dec = rsa.dec(raw)    except Exception as e:        from app.core.errors.exceptions import CommonExceptions        raise CommonExceptions.InvalidEncryptionField(e)    return dec이렇게 validate 함수를 구현해 놓으면 1차로 decrypt_fields 함수를 먼저 실행, 복호화된 값을 토대로 다시 한번 Field에 적용된 validate 검사를 진행하게 됩니다.Validator Sequencevalidator decorator를 통해 유효성 검증을 하게 되면@validator가 먼저 실행되고, @root_validator가 나중에 실행 되게 됩니다. 각 validate 함수에 print를 찍어보면 아래와 같은 결과가 나옵니다@validator('email', 'password', pre=True)def decrypt_fields(cls, raw):    print(f'decrypt_fields')    ...    return dec@root_validatordef root_validator(cls, values):    print(f'root_validator')    return valuesdecrypt_fieldsdecrypt_fieldsroot_validator2%부족한 BaseModel요청을 받은 Body 데이터 중에 industries의 id가 데이터베이스에 있는지를 확인해야 새로 생성된 모델과의 제대로 된 관계 설정을 할 수가 있습니다.Django의 drf를 통해 유효성 검사를 경험해 보았던 제게는 Serializer 안에서 접근할 수 있는 ORM 객체와 관련 함수에 대한 아쉬움이 상당히 많이 남아async def some(session: Session = Depends(get_db)):    ...    return등과 같이 Depends함수를 통해 database session 을 가져오는 것처럼 BaseModel에서도 가져올 수 있지 않을까라는 생각을 하며 여러 가지 시도를 해보았습니다.하지만 pydantic에서 sqlalchemy를 하나의 커넥션으로 가져오는 방법에 드라마틱한 방식은 없다는 쪽으로 결론을 내고 Request Body의 유효성 검증이 모두 끝난 후 Depends를 통해 전체적으로 유효성 검증을 해 보았습니다.def model_in(model: OrganizationModelIn, database: Session = Depends(get_db)):    industries = model.industries    errors = []    from pydantic.error_wrappers import ErrorWrapper    for idx, industry in enumerate(industries):    if industry.id and 0 &lt; industry.id and not is_exists_industry(database, industry.id):        e = OrganizationExceptions.Join.UnDefinedIndustryId        errors.append(ErrorWrapper(e(industry.id), loc=('body', 'industries', idx, 'id')), )    if len(errors) != 0:        raise ValidationException(errors=errors, model=model)    return model, database@router.post()async def post_join(model_n_session=Depends(model_in)):    ...    returncrud에서 raise 처리를 하는 걸 고민해 보았으나, is_exists_industry함수는 industry.id에 1:1로 대응하는 게 낫겠다는 판단에 model_in이라고 하는 validate 함수를 만드는 방식으로 진행했습니다.위와 같이 실제 router에 제공되는 메서드에서 model_in이라는 함수를 통해 session을 하나의 커넥션으로 묶어 실제 데이터베이스와의 유효성 검증을 수행하도록 해보았습니다.  CRUD 단에서 데이터를 Insert 할 때에 실제 유효한 ID를 전달받은 것인지 확인해 볼 수도 있었지만, CRUD 각각의 함수에 대한 테스트 문제, 그리고, pydantic이 기본적으로 매개변수 유효성 검사를 통과하지 못할 때 내려주는 422 에러와 동일한 형태인{  \"detail\": [    {      \"loc\": [\"body\", \"industries\", 0],      \"msg\": \"정의 되지 않은 Industry 객체의 ID({id})가 입력되었습니다\",      \"type\": \"type_error\"    }  ]}처럼 내려 주고 싶다는 고집때문에 위와 같은 형태를 고안해 보았네요.이전 API와의 동질화아이메디신의 API는 FastAPI 외에도 SpringBoot를 사용하고 있습니다. API Host와 Response는 어쩔 수 없이 다른 형태로 사용한다고 하더라도 FrontEnd 쪽에서 처리하는 변수명 명명 규칙을 최대한 변화를 주지 않도록 하기 위해서 CamelCase 문법을 따르도록 수정을 해주어야 하는 상황이 발생하였습니다.pydantic Field에는 alias=를 통해 내부에서 사용되는 변수명과 request / response에서 사용되는 변수명을 다르게 할 수 있습니다. 예를 들면field_name = str = Field(alias='fieldName')위와 같이 FastAPI 내부에서는 python의 변수 형태인 field_name 을 사용할 수 있으면서 외부에서 사용되는 변수명은 fieldName으로 사용할 수 있는 건데요.모든 필드명에 이런 식으로 alias를 붙이는 건 효율성이 떨어진다는 문제점이 있어 pyhumps를 이용해 BaseModel을 상속받은 CamelModel을 사용해 보는 것으로 방향을 잡아 보았습니다.from humps import camelizeclass CamelModel(BaseModel):    class Config:        alias_generator = camelize        allow_population_by_field_name = True이제 BaseModel 대신 CamelModel을 impliment 하는 것으로 Feild(alias=)를 생략할 수가 있습니다.class IndustryModelIn(CamelModel):    id: Optional[PositiveInt] = Field(title='ID', default=None)    industry_title: Optional[str] = Field(title='산업 명', default=None)위 모델에 대응하는 Request Body는 다음과 같습니다{  \"id\": null,  \"industryTitle\": \"title\"}마치며밸리데이션을 처리하는 데 있어 어느 정도까지 깊게 구현하느냐는 API의 퍼포먼스와도 크게 영향이 있다 보니, 무턱대고 아무렇게나 살을 붙이기는 어려운 것 같습니다. 더욱이 표준을 중요시하는 제게 문서에서 추천하지 않는 디자인 패턴을 적용한다는 건 거부감이 상당히 많이 들기도 했지만, 어떻게든 응답의 형태를 맞추고 싶다는 욕망과의 싸움이 삽질을 한참이나 하게 된 이유가 된 것 같기도 하네요.실제로 Django/DRF를 사용하다 API의 퍼포먼스 개선을 위해 FastAPI로 환경을 구성하였으나, 그 장점을 살리지 못한다면 FastAPI로 갈아탄 이유가 없다는 생각을 많이 하게 된 시간을 가졌습니다."
  }
  
]

