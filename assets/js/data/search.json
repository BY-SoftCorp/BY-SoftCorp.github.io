[
  
  {
    "title": "공통 기능을 가진 ViewModel 만들어 재사용하기",
    "url": "/posts/reuse-viewmodel/",
    "categories": "typescript, react, frontend",
    "tags": "design-pattern, mvvm",
    "date": "2024-04-26 10:16:00 +0900",
    





    
    "snippet": "ViewModel을 재사용하기 위한 고찰이전 블로그 글에서 MVVM 패턴을 적용했던 과정에 대해 남겨보았습니다. 그 이후로도 저는 여러가지 ViewModel과 Model을 구현해보았는데요, 매일 마주하는 코드인데도 불구하고 고쳐야 할 점이 매번 새롭게 보이고 있습니다. 쉽지 않은 내용인 만큼 아직도 MVVM 패턴에 익숙해지는 중인 것 같습니다. 최근 ...",
    "content": "ViewModel을 재사용하기 위한 고찰이전 블로그 글에서 MVVM 패턴을 적용했던 과정에 대해 남겨보았습니다. 그 이후로도 저는 여러가지 ViewModel과 Model을 구현해보았는데요, 매일 마주하는 코드인데도 불구하고 고쳐야 할 점이 매번 새롭게 보이고 있습니다. 쉽지 않은 내용인 만큼 아직도 MVVM 패턴에 익숙해지는 중인 것 같습니다. 최근 한달동안 가장 많이 고민 했던 내용이 MVVM이었던 터라 이번 글도 MVVM과 관련된 내용이지만, 오늘은 저번보다 조금! 더 발전한 내용을 가지고 와보았습니다.처음 MVVM 패턴을 적용하면서는 “이렇게 작성하면 이런저런 부분에서 재사용이 가능하겠구나!” 하는 대략적인 생각을 했고, 몇가지의 ViewModel과 Model을 더 만들어보며 비슷하게 생긴 컴포넌트들에 ViewModel을 재사용 해보기도 했습니다. 모양새가 유사한 컴포넌트들은 서로 다른 모듈이어도 ViewModel을 재사용하기가 어렵지 않았습니다. 생긴것이 비슷하니 비교적 추상화가 쉬웠기 때문입니다. 하지만 이번에 제가 가져온 컴포넌트는 조금 다르게 생긴 이 두 친구들입니다.첫번째 컴포넌트는 메뉴 컴포넌트, 두번째 컴포넌트는 네비게이션 컴포넌트 입니다.MVVM 패턴에 익숙하신 분들은 어떻게 생각하실지 모르겠지만, 저는 이 두 컴포넌트를 처음 봤을때 “모양이 다르게 생겼는데 어떻게 ViewModel을 재사용하지?”라는 생각을 했습니다. 하지만 ViewModel의 역할을 다시 잘 생각해보면, UI를 보여주는 일을 하는 것도 아니고 특정 데이터를 가져오는 일을 하지도 않습니다. 단순히 어떤 데이터를 어떠한 형태로 전달해주기만 합니다. 즉, 모양이 다르고, 사용하는 데이터가 달라도, 그 기능이 비슷하면 ViewModel은 재사용될 수 있습니다.1. 공통 기능 추상화하기이제 두 컴포넌트의 겉모습은 잊어야 합니다. 그래야 추상화가 쉬워지니까요. 우선, 두 컴포넌트가 어떤 기능을 동일하게 수행하는지 생각해봅니다.둘 다 어떤 선택지를 클릭했을 때, 해당 선택지에 해당하는 결과물을 내려주는 기능을 합니다. 기능에 집중해보니 이 두 컴포넌트는 같은 기능을 하고 있다는 것을 알게 되었습니다. 이제 이 기능들을 포함하고 있는 ViewModel을 작성해볼까요?2. 공통 기능을 가진 ViewModel 구현하기function OptionSelectViewModel(data: OptionListType): OptionSelectVM {\tconst [selectedOption, setSelectedOption] = useState('')        // 어떤 메뉴가 클릭되었는지 기록하는 함수\tfunction handleSelectMenu(option: string) {\t\tsetSelectedMenu(option)\t}\t// 클릭된 메뉴에 따라 알맞은 결과물을 리턴해주는 함수\tfunction getResult() {\t\treturn (\t\t\tdata.getList().filter((it) =&gt; it.getTitle() === selectedOption) ?? []\t\t)\t}\t// 전체 메뉴를 선택했을 때 전체보기로 메뉴 리셋을 해주는 함수\tfunction handleResetOptions(section?: string) {\t\tsetSelectedOption('')\t}\treturn {\t\thandleSelectMenu,\t\tgetResult,\t\thandleResetOptions,\t}}두 컴포넌트의 공통된 기능들을 포함한 ViewModel이 만들어졌습니다. 이제 이 ViewModel에 전달해줄 Model도 작성해봅시다.3. ViewModel에 전달해줄 Model 구현하기class OptionItem implements OptionItemType {\tprivate readonly title: string\tconstructor(raw: string) {\t\tthis.title = raw.category\t}\tgetTitle = () =&gt; this.title}class OptionList implements OptionListType {\tprivate readonly list: OptionItemType[]\tconstructor(raw: OptionItemType[]) {\t\tthis.list = raw\t}\tgetList = () =&gt; this.list}// 이렇게 구현해버리면 OptionListType 인터페이스를 구현할 수 없어 ViewModel이 인자로 받지 못하게 됨.class OptionMenu {\tprivate readonly list: OptionMenuCategoryType[]\tconstructor(raw: OptionMenuCategoryType[]) {\t\tthis.list = raw\t}\tgetList = () =&gt; this.list}그런데 여기서 한가지 문제가 생겼습니다. 위에 작성한 Model은 네비게이션 컴포넌트에 사용되는 데이터 모델에만 적용되고 메뉴 컴포넌트에 사용되는 데이터 모델에는 적용되지 않습니다. 네비게이션 컴포넌트는 메뉴를 선택하면 해당 메뉴의 title만 리턴해주면 되는데, 메뉴 컴포넌트는 해당 메뉴의 하위 카테고리 리스트를 내려주어야 하기 때문입니다.ViewModel은 OptionListType 타입만 인자로 받는데, 메뉴 컴포넌트용 데이터 모델을 인자로 받는 ViewModel을 새로 만들어야한다면 기존의 ViewModel을 재사용할 수 없게 됩니다. 어떻게 할까 방법을 고민하다가, 클래스는 인터페이스를 다중 구현할 수 있다는 점을 이용해보기로 했습니다.class OptionItem implements OptionItemType {\tprivate readonly title: string\tconstructor(raw: string) {\t\tthis.title = raw.name\t}\tgetTitle = () =&gt; this.title}class OptionList implements OptionListType, OptionItemType {\tprivate readonly list: OptionItemType[]\tconstructor(raw: OptionItemType[]) {\t\tthis.list = raw\t}\tgetList = () =&gt; this.list\t// 타입을 맞추기 위해 임의의 값을 넣어줌\tgetTitle = () =&gt; String(this.list)}class OptionMenu implements OptionListType {\tprivate readonly list: OptionItemType[]\tconstructor(raw: OptionItemType[]) {\t\tthis.list = raw\t}\tgetList = () =&gt; this.list}OptionList를 OptionItemType 인터페이스에 맞추기 위해 메서드를 끼워맞추는 과정이 필요했지만, 무사히 두개의 인터페이스를 구현했습니다. 이제 돌려주는 값의 데이터 타입이 달라 OptionList에 들어갈 수 없었던 메뉴 컴포넌트의 데이터가 OptionMenu를 통해 ViewModel에 사용되어질 수 있게 되었습니다. 네비게이션 컴포넌트는 기존의 OptionList와 OptionMenu 둘 다 사용가능합니다.const navPreData = NavTitleList.map((it) =&gt; new OptionItem(it))const navData = new OptionList(navPreData)return (    &lt;Nav       data={OptionSelectViewModel(navData)}     /&gt;)const menuPreData = MenuCategoryList.map((it) =&gt; new OptionList(it))const menuData = new OptionMenu(menuPreData)return (    &lt;Menu      data={OptionSelectViewModel(menuData)}    /&gt;)이제 이렇게 ViewModel을 두개의 View에 재사용할 수 있습니다.참고로 아래의 컴포넌트도 같은 ViewModel을 사용할 수 있답니다. 기능이 비슷하다는 생각이 드시나요?마치며어려운 과정은 아니었지만, 보이는 것에서 멀어지고 기능에 집중한 추상화를 진행했다는 점에서 한단계 성장했다는 생각을 하게 된 시간이었습니다. 또, 개인적인 성장 뿐만 아니라 코드적인 측면에서도 중복코드를 줄이고, 유닛 테스트를 진행하기에도 더욱 용이한 발전된 코드가 되었습니다. ViewModel은 비즈니스 로직을 UI에서 분리하고, 더욱 작은 조각으로 만들어주어 ‘단위’별로 테스트가 가능하게 해주는 장점을 가지는데, 이 ViewModel을 재사용하게 되면 테스트를 진행해야 하는 모듈의 수가 적어지기 때문에 단위 테스트를 진행하기가 더욱 편해집니다. 다음에는 ViewModel과 Model로 진행한 단위 테스트에 대해서도 글을 남겨보면 좋을 것 같습니다. 다음 글에서 만나뵙겠습니다 안녕 🤗"
  },
  
  {
    "title": "신입 프론트엔드 개발자의 MVVM 패턴 적용기",
    "url": "/posts/apply-mvvm-design/",
    "categories": "typescript, react, frontend",
    "tags": "design-pattern, mvvm",
    "date": "2024-03-26 10:47:00 +0900",
    





    
    "snippet": "MVVM 패턴은 디자인 패턴의 한 종류로, Model, View, ViewModel을 사용해 UI 관련 로직과 비즈니스 로직을 명확하게 분리합니다. 취업을 준비하던 시기에 진행했던 토이 프로젝트는 규모가 작아 이러한 패턴을 적용할 필요성을 느끼지 못했습니다. 그러나 프론트엔드 개발자로 일을 시작하고 사용자들이 사용할 실제 서비스를 제작하며, 코드의 유...",
    "content": "MVVM 패턴은 디자인 패턴의 한 종류로, Model, View, ViewModel을 사용해 UI 관련 로직과 비즈니스 로직을 명확하게 분리합니다. 취업을 준비하던 시기에 진행했던 토이 프로젝트는 규모가 작아 이러한 패턴을 적용할 필요성을 느끼지 못했습니다. 그러나 프론트엔드 개발자로 일을 시작하고 사용자들이 사용할 실제 서비스를 제작하며, 코드의 유지보수성과 재사용성을 높이기 위해 MVVM 패턴을 적용해보는게 좋을것 같다는 코드리뷰 피드백을 받게 되었습니다. 신입 프론트엔드 개발자로써 한번도 써보지 않았던 MVVM 패턴을 어떻게 코드에 적용했는지, 또 리팩토링을 진행하며 어떤 부분을 고민했었는지 글을 통해 나눠보고자 합니다.리팩토링 과정초기 코드interface DropdownListProps {  data: string[];  placeholder: string;}function DropdownList(props: DropdownListProps) {  const [isListOpen, setIsListOpen] = useState&lt;boolean&gt;(false);  const [selectedOption, setSelectedOption] = useState&lt;string&gt;(\"\");  const { data, placeholder } = props;  useEffect(() =&gt; {    setSelectedOption(placeholder);  }, []);  return (    &lt;DropdownListContainer onClick={() =&gt; setIsListOpen(!isListOpen)}&gt;      {selectedOption}      {isListOpen ? (        &lt;DropdownListOptionContainer&gt;          {data.map((option) =&gt; (            &lt;DropdownListOption key={option} onClick={() =&gt; setSelectedOption(option)}&gt;              {option}            &lt;/DropdownListOption&gt;          ))}        &lt;/DropdownListOptionContainer&gt;      ) : (        &lt;div /&gt;      )}    &lt;/DropdownListContainer&gt;  );}export default DropdownList가져온 코드는 공통 컴포넌트로 제작한 드롭다운 리스트 컴포넌트입니다. 제일 처음에 작성했던 코드인데, 컴포넌트를 사용하는 곳에서 서버 데이터를 props로 넘겨받고 그 데이터를 바로 TSX에 적용해주는 형식입니다. 하나의 파일에서 컴포넌트의 모든 것을 컨트롤 하고 있기 때문에 당연히 UI 로직과 비즈니스 로직은 구분되어있지 않습니다.이 컴포넌트에 MVVM 패턴을 적용해보라는 과제를 받고 로직을 어떻게 나눠야 하나 많은 고민을 했습니다. View가 가져가야하는 부분은 TSX가 리턴되는 부분으로 비교적 명확하게 보였으나, 데이터를 다루는 비즈니스 로직이 보이지 않았기 때문입니다. 그리고 ViewModel을 실제로 어떻게 구현해야하는지 감이 잡히지 않았습니다. 그래서 우선 데이터를 불러오는 부분을 Model로 분리해보는 일부터 시작해보기로 했습니다. View는 어느정도 완성이 된 상태이니 Model을 작성하고 나면 ViewModel의 역할도 보이지 않을까? 하는 생각이었습니다.1차 리팩토링// Modelconst rawDataCountries = ['Korea', 'Japan', 'Singapore', 'Australia']interface DropdownListItem {    getTitle: () =&gt; string    isSelected: () =&gt; boolean    setSelected: (isSelected: boolean) =&gt; void    isSelectable: () =&gt; boolean}class DropdownListItemCountry implements DropdownListItem {    private readonly title: string    private selected: boolean    private readonly selectable: boolean = true    constructor(title: string) {        this.title = title        this.selected = false        if (!title) this.selectable = false    }    getTitle = () =&gt; this.title    isSelected = () =&gt; this.selected    setSelected = (selected: boolean) =&gt; {        this.selected = selected    }    isSelectable = () =&gt; this.selectable}interface DropdownListProcessedData {    getCountryList: () =&gt; DropdownListItem[]}class ProcessedData implements DropdownListProcessedData {    private countryList: DropdownListItem[]    constructor() {        this.countryList = rawDataCountries.map(            (item) =&gt; new DropdownListItemCountry(item)        )    }    getCountryList = () =&gt; this.countryList}export default ProcessedData1차 리팩토링 후 Model로 분리한 코드입니다. 문자열 배열 형식의 더미 데이터를 미리 정의해두고, 해당 데이터가 서버에서 넘어왔다고 가정한 후 코드를 작성했습니다.데이터를 불러와 따로 분리해놓고 나니, 해당 선택지가 선택이 된 상태인지, 선택이 가능한 상태인지에 관한 정보도 함께 들어있으면 좋겠다는 생각이 들었습니다. 그래서 속성으로는 제가 원하는 정보를 저장하고, 행위는 해당 객체가 가진 정보를 수정할 수 있도록 각각의 선택지들을 객체로 만들어주는 클래스를 만들어주었습니다. 저는 간단하게 어떤 선택지인지 알려주는 title과 해당 선택지가 선택되었는지 알려주는 selected, 선택지가 선택이 가능한지 알려주는 selectable 속성 세 개를 정의해주었습니다. 그리고 세 개의 속성을 리턴해주는 메서드와 선택지가 선택되었을때 selected 속성값을 바꿔주는 setSelected 메서드도 포함해주었습니다. 단순하게 이름만 가지던 선택지들이 selected와 selectable 속성을 가지게 됨으로써 드롭다운 리스트에서 어떤 선택지를 선택했을 때, 다른 컴포넌트에서 선택된 옵션을 받아 제품 목록을 보여주는 등의 방법으로 재사용될 수 있게 되었습니다.그리고 최종적으로 각각의 선택지 객체들을 리스트로 모아주는 객체를 만들어 ViewModel이 바로 활용할 수 있는 형태를 반환하도록 했습니다.// ViewModelimport { useState } from \"react\";import ProcessedData from \"@components/dropdown-list/model\";function DropdownListViewModel() {  const [isListOpen, setIsListOpen] = useState&lt;boolean&gt;(false);  const [selectedCountryOption, setSelectedCountryOption] = useState&lt;string | undefined&gt;(undefined);  const countryList = new ProcessedData().getCountryList();  function handleListDisplay() {    setIsListOpen(!isListOpen);  }  function handleSelectOption(idx: number, list: string) {    if (list === \"countryList\") setSelectedCountryOption(countryList[idx].getTitle());  }  return { countryList, isListOpen, selectedCountryOption, handleListDisplay, handleSelectOption };}export default DropdownListViewModel;View와 Model의 윤곽이 잡히고 나니 ViewModel도 구현이 가능했습니다. View와 Model이 직접적으로 연결이 된다면 서로에 대한 의존성이 높아지기 때문에, 단순한 작업이라도 ViewModel 통하도록 해주었습니다. ViewModel이 Model로부터 데이터를 전달받아 View로 전달해주고, View에서 Model을 변경하는 인터렉션이 일어나면 ViewModel을 통해 Model에게 변경점을 알리게 됩니다.// View// ... Styled components 등 다른 import들import useDropdownListViewModel from \"@components/dropdown-list/view-model\";interface DropdownListProps {  placeholder: string;}function DropdownList(props: DropdownListProps) {  const {    countryList,    isListOpen,    selectedCountryOption,    handleListDisplay,    handleSelectOption,  } = useDropdownListViewModel();  const { placeholder } = props;  const text = !selectedCountryOption ? placeholder : selectedCountryOption;  return (    &lt;DropdownListContainer onClick={handleListDisplay}&gt;      {text}      {isListOpen ? (        &lt;DropdownListOptionContainer&gt;          {countryList.map((el, idx) =&gt; (            &lt;DropdownListOption              key={el.getTitle()}              onClick={() =&gt; handleSelectOption(idx, \"countryList\")}            &gt;              {el.getTitle()}            &lt;/DropdownListOption&gt;          ))}        &lt;/DropdownListOptionContainer&gt;      ) : (        &lt;div /&gt;      )}    &lt;/DropdownListContainer&gt;  );}View는 이전과 큰 차이는 없지만, 데이터를 받아오고 수정하는 모든 로직을 ViewModel을 통해서 받게 되었습니다.첫 리팩토링을 거친 후 받은 피드백은 두 가지였습니다.첫 번째 피드백은 Model과 ViewModel이 특정 데이터(Country 선택지 데이터)에 맞춰져있다는 것이었습니다. 그렇게 되면 Model과 ViewModel을 재사용하기가 힘들기 때문에 다양한 선택지 데이터를 적용하여 사용할 수 있도록 수정해달라고 하셨습니다.두 번째 피드백은 Model에서 리스트를 만들어주는 클래스가 의미없는 인스턴스를 생성한다는 것이었습니다. 선택지를 추가한다거나 삭제하는 등 리스트 데이터를 변경하는 로직이 필요하다면 리스트를 다루는 클래스가 필요하겠지만, 현재로서는 그런 로직이 없으므로 클래스를 사용하지 않는 것이 좋겠다고 하셨습니다.2차 리팩토링// Modelinterface DropdownListItem {  getTitle: () =&gt; string;  isSelected: () =&gt; boolean;  setSelected: (isSelected: boolean) =&gt; void;  isSelectable: () =&gt; boolean;}class DropdownListItemCreation implements DropdownListItem {  private readonly title: string;  private selected: boolean;  private readonly selectable: boolean = true;  constructor(title: string) {    this.title = title;    this.selected = false;    if (!title) this.selectable = false;  }  getTitle = () =&gt; this.title;  isSelected = () =&gt; this.selected;  setSelected = (selected: boolean) =&gt; {    this.selected = selected;  };  isSelectable = () =&gt; this.selectable;}const rawDataCountries = [\"Korea\", \"Japan\", \"Singapore\", \"Australia\"];const countryData = rawDataCountries.map((it) =&gt; new DropdownListItemCreation(it));export type { DropdownListItem };export { countryData };// ViewModelimport { useState } from \"react\";import { DropdownListItem } from \"@components/dropdown-list/model\";import { ViewModelInterface } from \"@components/dropdown-list\";function DropdownListViewModel(data: DropdownListItem[]): ViewModelInterface {  const [isListOpen, setIsListOpen] = useState&lt;boolean&gt;(false);  const [selectedOption, setSelectedOption] = useState&lt;string | undefined&gt;(undefined);  const dropdownList = data;  function handleListDisplay() {    setIsListOpen(!isListOpen);  }  function handleSelectOption(idx: number) {    setSelectedOption(dropdownList[idx].getTitle());  }  return { dropdownList, isListOpen, selectedOption, handleListDisplay, handleSelectOption };}export default DropdownListViewModel;export type { ViewModelInterface };피드백을 받았던 내용을 바탕으로 두 번째 리팩토링을 진행했습니다. 우선 해당 Model이 Country 데이터만 다루는 것처럼 보이지 않도록 이름에서 Country라는 단어를 제거하였습니다. 그리고 Country 리스트 데이터만 리턴하는 클래스를 삭제하고, 필요한 데이터는 변수에 바로 담아 map 함수로 요소들을 인스턴스화 시켜 배열에 담아 export 해주었습니다. 만약 Country 데이터가 아닌 Fruit 데이터가 사용된다면 Fruit 리스트 데이터를 담을 변수를 선언한 후, 같은 클래스로 인스턴스화 하여 재사용할 수 있겠죠?ViewModel에서도 특정 데이터를 지칭하는 단어가 없어져 혼란을 방지하고 데이터와 상관없이 View와 Model을 이어주는 역할을 한다는 것이 더 잘 보여지게 되었습니다.// View// ... Styled components 등 다른 import들import { DropdownListItem } from \"@components/dropdown-list/model\";interface ViewModelInterface {  dropdownList: DropdownListItem[];  isListOpen: boolean;  selectedOption?: string;  handleListDisplay: () =&gt; void;  handleSelectOption: (idx: number) =&gt; void;}interface DropdownListProps {  placeholder: string;  viewModelProps: ViewModelInterface;}function DropdownList(props: DropdownListProps) {  const { placeholder, viewModelProps } = props;  const { dropdownList, isListOpen, selectedOption, handleListDisplay, handleSelectOption } = viewModelProps;  const text = !selectedOption ? placeholder : selectedOption;  return (    &lt;DropdownListContainer onClick={handleListDisplay}&gt;      {text}      {isListOpen ? (        &lt;DropdownListOptionContainer&gt;          {dropdownList.map((el, idx) =&gt; (            &lt;DropdownListOption key={el.getTitle()} onClick={() =&gt; handleSelectOption(idx)}&gt;              {el.getTitle()}            &lt;/DropdownListOption&gt;          ))}        &lt;/DropdownListOptionContainer&gt;      ) : (        &lt;div /&gt;      )}    &lt;/DropdownListContainer&gt;  );}export default DropdownList;export type { ViewModelInterface };View 또한 특정 데이터에 얽혀있는 컴포넌트가 아니어서, ViewModel로부터 받아온 데이터의 이름을 바꿔준 것 만으로도 여러곳에서 다양하게 사용하기 편해졌습니다.그리고, View와 ViewModel을 연결할 때는 View 내부에서 ViewModel을 불러오는 것 보다 컴포넌트를 사용하는 곳에서 props를 통해 ViewModel을 넘겨주는 것이 테스트를 진행하기 용이하다고 알려주셔서 연결방법을 바꿔주었습니다.&lt;DropdownList placeholder={\"선택해주세요\"} viewModelProps={DropdownListViewModel(countryData)} /&gt;컴포넌트를 사용할 때 이렇게 ViewModel에 데이터를 담은 후 props로 전달해주게 됩니다.3차 리팩토링// ViewModelimport { useState } from \"react\";import { DropdownListItem } from \"@components/dropdown-list/model\";import { DropdownViewModelInterface } from \"@components/dropdown-list\";function DropdownListViewModel(data: DropdownListItem[]): DropdownViewModelInterface {  // selectedOption 상태값의 경우 단순히 어떤 선택지가 골라졌는지 view에서 보여주기 위해 사용하는 것뿐만 아니라, form을 제출한다던지 하는 경우에 그 값을 넘겨주기 위해 사용될 가능성이 있다.  // 그렇게 넘겨진 값은 다른 컴포넌트의 뷰를 조정하는 과정에서 쓰일 수 있다.  // 따라서 이 상태값은 특정 뷰에서 관리되는 것이 아니라 뷰모델에서 관리한다.  const [selectedOption, setSelectedOption] = (useState &lt; string) | (undefined &gt; undefined);  const dropdownList = data;  function handleSelectOption(idx: number) {    setSelectedOption(dropdownList[idx].getTitle());    dropdownList.map((it: DropdownListItem, index: number) =&gt; it.setSelected(idx === index));  }  return { dropdownList, selectedOption, handleSelectOption };}export default DropdownListViewModel;// View// ... Styled components 등 다른 import들import { DropdownListItem } from \"@components/dropdown-list/model\";interface DropdownViewModelInterface {  dropdownList: DropdownListItem[];  selectedOption?: string;  handleSelectOption: (idx: number) =&gt; void;}interface DropdownListProps {  placeholder: string;  viewModelProps: DropdownViewModelInterface;}function DropdownList(props: DropdownListProps) {  const [isListOpen, setIsListOpen] = useState&lt;boolean&gt;(false);  const { placeholder, styleProps, viewModelProps } = props;  const { dropdownList, selectedOption, handleSelectOption } = viewModelProps;  const text = !selectedOption ? placeholder : selectedOption;  return (    &lt;DropdownListContainer onClick={() =&gt; setIsListOpen(!isListOpen)}&gt;      {text}      {isListOpen ? (        &lt;DropdownListOptionContainer&gt;          {dropdownList.map((el, idx) =&gt; (            &lt;DropdownListOption key={el.getTitle()} onClick={() =&gt; handleSelectOption(idx)}&gt;              {el.getTitle()}            &lt;/DropdownListOption&gt;          ))}        &lt;/DropdownListOptionContainer&gt;      ) : (        &lt;div /&gt;      )}    &lt;/DropdownListContainer&gt;  );}export default DropdownList;export type { DropdownViewModelInterface };ViewModel 안의 코드를 보다보니 UI 로직이 포함되어있는 것이 보였습니다. 리스트가 열렸는지 확인하는 로직은 View가 관리해야 할 영역이라고 생각되어 ViewModel에 있던 코드를 View로 옮겨주었습니다. 이를 통해 UI 로직은 오롯이 View에서 관리하게 되었고, 불필요하게 ViewModel을 거쳐 화면을 바꾸는 코드가 삭제되어 간결해졌습니다.마치며몇 단계를 거쳐 완벽하지는 않지만 Model-View-ViewModel의 역할이 구분된 코드가 만들어졌습니다. MVVM 패턴을 적용하면서 가장 어려웠던 점은 ViewModel의 역할을 찾는 것이었습니다. 이전에는 데이터를 UI에 바로 적용했기 때문에 ViewModel이라는 것을 한번도 사용해보지 않았기 때문인 것 같습니다. 하지만 이렇게 코드를 나누고 보니 디자인이 다른 새로운 드롭다운 리스트 컴포넌트를 만들게 되더라도 미리 만들어놓은 ViewModel과 Model을 쉽게 재사용하면 되겠다는 생각이 들었습니다. 그리고 중복되는 코드가 줄어들면서 유지보수도 훨씬 쉬워질 것 같습니다. 저는 이 경험을 시작으로, 복잡한 로직을 더 쉽게 다룰수 있는 방법을 계속 고민하고 공부해보아야겠습니다. 😊"
  },
  
  {
    "title": "FastAPI와 SQLAlchemy 환경에서 Database Test",
    "url": "/posts/fast-api-db-test/",
    "categories": "python, backend",
    "tags": "fastapi, sqlalchemy, unittest",
    "date": "2022-06-26 15:32:00 +0900",
    





    
    "snippet": "FIRST 원칙단위 테스트를 수행하는 데 있어 여러 가지 가이드가 있지만 일반적으로 적용하고 있는 FIRST 원칙은 다음과 같습니다.  Fast  Independent  Repeatable  Self-Validating  Timely하지만 22년 6월 기준 FastAPI와 SQLAlchemy에서 제공하는 공식문서상의 튜토리얼을 따라가면 2번째 항목인 ...",
    "content": "FIRST 원칙단위 테스트를 수행하는 데 있어 여러 가지 가이드가 있지만 일반적으로 적용하고 있는 FIRST 원칙은 다음과 같습니다.  Fast  Independent  Repeatable  Self-Validating  Timely하지만 22년 6월 기준 FastAPI와 SQLAlchemy에서 제공하는 공식문서상의 튜토리얼을 따라가면 2번째 항목인 Independent를 만족하지 못하는 현상이 발생합니다. 이는 매우 안타까운 상황이며, 많은 기술 블로그를 보아도 위와 같은 상황으로 고민하는 개발자들을 만나볼 수 있죠.이 포스팅은 이런 문제에 대해 다른 Unit-Test lib에서와 같이 독립성을 보장하는 데이터베이스 환경을 구성하는 방향으로 잡아보았습니다.Database EngineFastAPI에서 제공하는 공식 문서대로 테스트 환경에서 Database를 이용해야 할 때 sqlite:///:memory:와 같이 SQLite를 이용하라고 권고하고 있습니다.이와 같은 방식은 대부분 문제가 발생하지 않지만, 실제 서비스가 sqlite로 구성되어있지 않다면 몇몇 field 등에서는 실제로 구성된 스키마와 다른 문제 때문에 완벽한 테스트를 보장할 수 없다는 문제가 있습니다.Test가 성공적으로 수행되고 난 후의 코드는 실제상황에서 안정적인 동작을 보장해야 하는데 MySQL을 사용하는 우리 서비스에서 SQLite를 이용한 Database 테스트를 수행할 수는 없었습니다.또한 실제 환경과 동일한 환경을 구성하기 위한다는 명분으로 아무리 개발 서버라고 하더라도 Test를 그곳에서 실행할 수는 없다는 판단과 Test의 Performance를 위해 로컬 환경에 MySQL 서버를 생성하는 쪽으로 방향을 잡고 Docker를 이용해 MySQL 서버를 띄워보았습니다.docker run --platform linux/amd64 -p 3306:3306 --name test_db -e MYSQL_ROOT_PASSWORD=password -e MYSQL_DATABASE=test_db -e MYSQL_PASSWORD=password --restart=unless-stopped -d mysqlTest 환경변수 설정Test가 동작하는 환경이라고 하더라도 기본적으로 실제 환경과 거의 동일한 환경에서 작동되어야 합니다.하지만 Test 환경에서만 적용되어야 하는 환경변수에 대한 Mocking이 필요한데 pytest에서 제공해주는 pytest.ini를 통해 다음과 같이 Database의 환경변수 위주로 재구성하였습니다. 위 Section에서도 설명했듯이 실제 Database에서 테스트를 진행할 수는 없으니까 말이죠.[pytest]env =    APP_ENV=test    DATABASE_HOST=localhost    DATABASE_USER=root    DATABASE_PASSWORD=password    DATABASE_NAME=test_dbDatabase Engine 생성아이메디신 에서는 Database 접근에 대해서 SQLAlchemy라는 객체 형식으로 관리하고 있습니다. SQLAlchemy는 Python 환경에서 ORM을 제공해주는 라이브러리로, 상당히 많은 Python 기반의 프로젝트에서 사용하고 있을 정도로 범용성이 높다고 볼 수 있습니다. FastAPI의 공식 문서에서도 SQLAlchemy를 다루고 있기도 하죠.class Settings(BaseSettings):    ...    @property    def database_url(self):        return f'mysql+pymysql://{self.DATABASE_USER}:{self.DATABASE_PASSWORD}@' \\               f'{self.DATABASE_HOST}:{self.DATABASE_PORT}/{self.DATABASE_NAME}?charset=utf8mb4'...class SQLAlchemy:    @classmethod    def create_engine(cls):        setting_dict = dict(            DATABASE_URL=settings.database_url,            DATABASE_POOL_RECYCLE=settings.DATABASE_POOL_RECYCLE,            DATABASE_ECHO=settings.DATABASE_ECHO,        )        return SQLAlchemy(**setting_dict)    ......database = SQLAlchemy.create_engine()Settings 객체를 보면 database_url을 조합, 리턴 해주는 property에서 DATABASE_HOST, DATABASE_USER… 등의 환경변수가 있는데, 만약 구동되는 환경이 Test 환경이라면 앞서 pytest.ini에서 설정해준 환경변수가 적용되어 local.database를 바라보게 될 것입니다.conftest.pypytest에서는 테스트 환경에 필요한 fixture, plugin, module 등을 관리하기 위해 conftest.py라는 파일을 사용할 것을 권하고 있습니다. 이는 단위테스트가 동작할 때 필요한 given을 미리 정의 해놓은 파일로, 일종의 setUp 함수와 비슷하지만 동일하지는 않죠.또한 모든 단위테스트에서 단 하나의 session을 호출해야 테스트가 종료되었을 때 후속 작업을 일괄되게 처리할 수 있다는 점과 한 번의 단위테스트 내에서 몇 단계에 걸쳐 fixture를 호출해도 멱등성을 보장한다는 특징은 conftest를 사용해야 하는 이유이기도 하죠.이제 conftest에 Test 용 Database 세션을 관리하도록 해보겠습니다.from app.app_core.databases.conn import database@fixture(scope='session', autouse=True)def db():    from sqlalchemy_utils import create_database, database_exists, drop_database    engine = database.engine    _db = {        'engine': engine,        'session': sessionmaker(autocommit=False, autoflush=False, bind=engine),    }    if database_exists(engine.url):        drop_database(engine.url)    create_database(engine.url)    try:        from alembic.config import Config as AlembicConfig        from alembic.command import upgrade as alembic_upgrade, downgrade as alembic_downgrade        from app.app_core.settings import settings        alembic_config = AlembicConfig()        alembic_config.set_main_option('sqlalchemy.url', settings.database_url)        alembic_config.set_main_option('script_location', 'revision')        alembic_upgrade(alembic_config, 'head')        yield _db    finally:        engine.dispose()fixture에 제공되는 매개변수 중 scope='session'을 통해 해당 fixture가 테스트가 유지되는 동안 같은 인스턴스를 반환하도록 설정하였습니다. 이는 테스트 건당 데이터베이스를 생성하는 건 테스트의 성능 저하와도 밀접한 연관이 있기 때문입니다. 또한 autouse=True 옵션을 주어 명시적으로 db라는 fixture를 호출하지 않아도 데이터베이스가 구성될 수 있도록 처리하였습니다.이제 db 인스턴스가 필요한 어느 곳에서든 def test_some(db):와 같은 방식으로 database에 접근할 수 있습니다.하지만 대부분의 코드에서는 database 객체에 직접 접근 하는 경우보단 하나의 session에 접근하는 게 일반적입니다. 따라서 session 객체 역시 fixture로 관리해야 할 필요성을 느낍니다.@fixturedef engine(db):    engine = db['engine']    connection = engine.connect()    transaction = connection.begin()    yield engine    transaction.rollback()@fixturedef session(db) -&gt; Session:    session = db['session']()    session.begin_nested()    yield session    session.rollback()    session.close()현재까지 아이메디신의 FastAPI 프로젝트는 engine을 직접 제어하지는 않지만, 추후 필요할지도 모른다는 생각에 session을 만들면서 함께 만들어 보았습니다.단위 테스트 내에서 반드시 conftest에 정의된 session fixture를 사용할 필요는 없지만, 앞서 설명한 것과 같이 테스트가 종료된 후 다른 테스트에 영향을 주지 않기 위해서 처리하는 session.rollback() 부분이 정상적으로 동작하기 위해선 session fixture를 사용할 것을 권합니다.# 호출할 때마다 다른 인스턴스 생성# session.commit(), session.close() 처리가 완료되기 전에 다른 session에서 접근 시# 값이 반영되어 있지 않은 문제가 있음# 또한 fixture에서 사용한 rollback() 처리가 동작하지 않음def test_some():session = next(database.session())...# 호출할 때마다 같은 인스턴스 생성# flush() 처리만 되어있어도 데이터베이스에 값이 반영된 것처럼 보임# 가장 중요한 rollback() 처리 한 번으로 다른 테스트 코드에 영향을 주지 않음def test_some(session):dependency_overridesFastAPI에서는 router 호출 시 Depends를 이용해 여러 곳에서 같은 함수를 호출하더라도 단 하나의 인스턴스를 이용할 수 있는 방식을 제공합니다. 일종의 Singleton 패턴과도 같은 방식이죠. 그리고 테스트 환경에서 이 의존성을 Mocking 할 수 있는 방법을 dependency_overrides라는 방식으로 제공해주고 있습니다.dependency_overrides를 반드시 사용해야 하는 이유는 실제 동작 하는 코드인 router에서는 conftest의 fixture를 가져올 수 없기 때문입니다.일반적으로 router 안에서 사용되는 database.session은 다음과 같은 방식으로 구현됩니다.@router.post(    '/id',    summary='아이디 찾기',    ...)async def post_id(        session: Session = Depends(database.session),):    ...만약 dependency_overrides를 정의해 놓지 않은 상황이라면 router를 호출할 때마다 다른 인스턴스의 session이 생성될 것이며, 다음과 같은 테스트 코드에서 그 동작을 신뢰성을 보장할 수 없습니다.def test_some(client, session, admin_user):    customized_package = CustomizePackagePrice(...)    session.add(customized_package)    url = PATH_PAYMENTS_V1_0 + f'/customize_price_package?packageId={customized_package.id}'    user = gen_admin_user    client.force_authenticate(user)    res = client.get(url)    ...@router.get(    '/customize_price_package',    ...)async def get_customize_package_price(        query: CustomizePackagePriceQuery = Depends(),        session: Session = Depends(database.session),):    ...    package_id = query.package_id    packages = list_customize_package_price(session, package_id, user)    # dependency_overrides설정이 되어있지 않다면 다른 인스턴스의 session으로 인해 not found 발생    return paginate(packages)따라서 단위 테스트 실행 시 반드시 dependency_overrides를 구현해 주어야 동작의 신뢰도를 높일 수 있으며 FastAPI에서 제공하는 공식 문서상 구현 방법은 다음과 같습니다.def override_get_db():    try:        db = TestingSessionLocal()        yield db    finally:        db.close()app.dependency_overrides[get_db] = override_get_db하지만 이 방식대로 구현하게 되면 단위 테스트 내에서 사용하는 session과 router에서 사용되는 session이 다른 인스턴스를 사용하게 되는 문제가 있습니다. 위에서 지적한 동일한 인스턴스에 대한 접근이 위배 되는 상황이 발생하며, 무엇보다 한 번의 테스트가 끝난 후 그와 관련된 데이터의 rollback 처리가 수월하지 않다는 문제가 있죠.이 문제를 해결하기 위해선 이전에 구성한 fixture를 dependency injection 해주어야 하는데 이런 방식을 구상해 보았습니다.app.dependency_overrides[engine.session] = session위 코드가 잘 동작한다면 훌륭하겠지만, 아주 커다란 문제가 있습니다. 바로 session이라는 fixture는 db라는 다른 fixture를 매개변수로 받고 있다는 점과 fixture는 일종의 @property라는 점이죠. 아마도 당신이 위 코드를 실행하면 다음과 같은 오류를 만나게 될 것입니다.'&lt;sqlalchemy.orm.session.Session object at 0x1145520d0&gt; is not a callable object'난관에 부딪힌 상황이었지만, 다행히도 lambda 키워드를 사용해 생각보다는 간단하게 문제를 해결할 수 있었습니다. 또한 아이메디신에서 현재까지 개발된 테스트 코드는 Depends를 이용하기 위해선 TestClient를 이용해 router를 호출하는 때 외에는 없으므로 dependency_overrides를 TestClient를 호출하는 fixture에서 설정해주도록 구성해보았습니다.@fixturedef client(session):    # lambda식을 이용해 function 형태로 inject    app.dependency_overrides[engine.session] = lambda: session    from tests.test_routes import get_client    return get_client()위와 같은 구성으로 test 코드와 router에서 하나의 인스턴스 session을 사용하게 되어 router 테스트에서 완벽한 테스트 결과를 기대할 수 있게 되었습니다.환경 구성의 누락 방지만약 당신이 구현하고 있는 프로젝트의 데이터베이스에 대한 접근제어가 strict 하지 않은 상황이고, 프로젝트를 다른 환경에서 clone 하여 작업을 하려던 중 pytest.ini를 구성하는 걸 잊은 상태라면 pytest 명령어를 입력하는 순간if database_exists(engine.url):    drop_database(engine.url)설정에 따라 실제 데이터 베이스에 모든 테이블이 삭제되는 현상이 발생할 것입니다. 이는 실제 서비스가 중단될지도 모르는 매우 위험한 상황을 내포하고 있죠.제가 생각하는 이상적인 접근제어라면 database 인스턴스는 VPC 안에서 private 공간에 위치해야 하고, 해당 프로젝트를 개발하고 있는 Engineer라고 하더라도 직접적으로 데이터베이스에 접근할 수 있어서는 안 됩니다.하지만 여러 가지 상황으로 위와 같은 환경 구성이 어려운 경우 다음과 같은 검증 식을 conftest.py 최상단에 추가 함으로써, 데이터베이스를 삭제하는 실수를 방지할 수 있을것입니다.assert settings.APP_ENV == 'test', 'test 환경에서만 test 가능, `pytest.ini` 확인 필!'마치며단위테스트는 프로젝트를 개발해 나감에 있어 아주 기본적이지만 매우 중요한 절차이기 때문에 다른 포스팅 보단 조금 더 심도 있게 다루어 보았습니다. 아마도 다른 주제로 또다시 단위 테스트에 대해서 포스팅을 작성할 것 같다는 생각이 들기도 하네요.또 다른 단위 테스트 주제로 만나 뵙기를 희망합니다 :)"
  },
  
  {
    "title": "Python 열거형과 SQLAlchemy",
    "url": "/posts/annotated-enum/",
    "categories": "python, structure",
    "tags": "enum, sqlalchemy",
    "date": "2022-05-15 09:00:00 +0900",
    





    
    "snippet": "Python의 Enum Type기본적으로 Python의 열거형은 여러 이름을 같은 값에 대해 별칭으로 사용합니다.예를 들면 열거형의 멤버에 동일한 값을 가진 A와 B가 정의되어 있다면 B는 A의 별칭입니다.class Shape(Enum):    SQUARE = 2    DIAMOND = 1    CIRCLE = 3    ALIAS_FOR_SQUARE ...",
    "content": "Python의 Enum Type기본적으로 Python의 열거형은 여러 이름을 같은 값에 대해 별칭으로 사용합니다.예를 들면 열거형의 멤버에 동일한 값을 가진 A와 B가 정의되어 있다면 B는 A의 별칭입니다.class Shape(Enum):    SQUARE = 2    DIAMOND = 1    CIRCLE = 3    ALIAS_FOR_SQUARE = 2위 Shape를 예로 들어보면 ALIAS_FOR_SQUARE는 SQUARE의 별칭으로 SQUARE, ALIAS_FOR_SQUARE 중 어느 것을 조회해도 2(SQUARE)를 반환하게 됩니다.&gt;&gt;&gt; Shape.SQUARE&lt;Shape.SQUARE: 2&gt;&gt;&gt;&gt; Shape.ALIAS_FOR_SQUARE&lt;Shape.SQUARE: 2&gt;&gt;&gt;&gt; Shape(2)&lt;Shape.SQUARE: 2&gt;API로 열거형을 전달할때 고민FastAPI는 router의 요소를 자동으로 문서화해 주는 기능이 있습니다. 이는 문서작성의 시간을 상당 부분 줄여주어 매우 편리한 기능이라고 생각하는데 Python 열거형에 대해 조금은 부족한 부분이 있죠.class RequestEmailAuthType(str, Enum):    JOIN = '1'    RESET_PASSWORD = '2'...class RequestEmailAuthIn(CamelModel):    request_type: RequestEmailAuthType = Field(title='요청 타입')위와 같은 열거형을 API 요청에서 필드로 받는다고 가정하면 redoc 문서는 아래와 같이 나오게 됩니다.이 문서에는 한 가지 큰 문제가 있습니다. 바로 \"1\"과\"2\"가 무엇을 뜻하는지 문서만 보아서는 알 수가 없다는 점이죠. 다행히도 이 문제는 조금 간단하게 해결할 수 있습니다. 바로 Python의 __doc__ 기능을 이용해서죠.class RequestEmailAuthType(str, Enum):    \"\"\"    1: 가입, 2: 비밀번호 초기화    \"\"\"    JOIN = '1'    RESET_PASSWORD = '2'이런 식으로 열거형에 __doc__항목을 추가해 주면 redoc은 아래와 같이 자동으로 각각의 값에 대한 설명을 만들어줍니다.SQLAlchemy와의 연동FastAPI에서 ORM 기능을 이용하기 위해선 SQLAlchemy라는 OpneSource를 이용합니다. 매우 잘 만들어진 OpenSource이지만 Database에 열거형의 타입을 넣을 때 열거형이 값(value)이 아닌 키(name)가 들어간다는 것입니다.키가 들어가는 건 나름 의미 있는 데이터가 들어가는 것이라 데이터 베이스의 값을 직접 열어볼 때 조금은 더 직감적일 수 있다는 장점이 있긴 하지만, 최근 개발 동향상 데이터베이스에 직접 접근해서 CRUD 작업을 하는 경우는 잘 없다 보니 저장되는 데이터의 용량을 줄이기 위해 위에서 언급했던 별칭을 이용해 보도록 하겠습니다.class RequestEmailAuthType(str, Enum):    JOIN = '1'    RESET_PASSWORD = '2'    J = '1'    R = '2'SQLAlchemy가 알아서 별칭만을 알아서 추려낸 후 데이터베이스의 키로 설정해 줄 수 있다면 더 이상 손볼게 없어지지만, 아쉽게도 위 코드만으로는 다음과 같은 스키마로 enum 필드가 생성됩니다.`request_type` enum('JOIN','RESET_PASSWORD','J','R') NOT NULL,J와 R로 데이터를 채울 수는 있지만 썩 만족스럽지 않습니다. 저장되는 데이터의 크기를 줄여보자는 의도와 상충되는 부분이 있고, 무엇보다 동일한 의미의 값이 중복되어 표시될 수도 있다는 점이 혼란을 야기할 수도 있을 것 같다는 판단입니다.SQLAlchemy에서 Enum을 처리하는 방식을 살펴보면 대략 아래와 같이 구성되어 있습니다.if len(enums) == 1 and hasattr(enums[0], \"__members__\"):    self.enum_class = enums[0]    _members = self.enum_class.__members__    aliases = [n for n, v in _members.items() if v.name != n]    if self._omit_aliases is NO_ARG and aliases:        util.warn_deprecated_20(            \"The provided enum %s contains the aliases %s. The \"            \"``omit_aliases`` will default to ``True`` in SQLAlchemy \"            \"2.0. Specify a value to silence this warning.\"            % (self.enum_class.__name__, aliases)        )__members__를 통해 Enum 필드에 들어갈 항목들을 가져오는데, 아쉽게도 별칭만을 넣을 수 있는 옵션이 따로 없네요. 원키와 별칭의 순서를 바꾼 후 (별칭을 원키처럼 활용) _omit_aliases옵션을 줄까 생각해 보기도 하였지만, 별칭과 원키의 순서를 보장하고 싶다는 생각에 __members__를 조금 수정해 보기로 했습니다.class AliasOnlyEnumMeta(EnumMeta):    @property    def __members__(cls):        sp = super().__members__        items = sp.items()        alias_values = [v.value for n, v in items if v.name != n]        filtered = [n for n, v in items if (v.name == n and v.value not in alias_values) or v.name != n]        members = {k: v for k, v in items if k in filtered}        return membersclass RequestEmailAuthType(str, Enum, metaclass=AliasOnlyEnumMeta):    JOIN = '1'    RESET_PASSWORD = '2'    J = '1'    R = '2'Enum의 metaclass를 커스터마이징 한 AliasOnlyEnumMeta를 생성 후 __members__ property를 override 해서 별칭이 없는 키와 별칭이 있다면 별칭 만을 내려 주도록 해보았습니다.이제 이 코드를 적용해서 스키마를 생성해 보면 다음과 같이 Field가 생성되는 걸 확인할수 있죠.`request_type` enum('J','R') NOT NULL,Enum의 값으로 사용되는 키가 상당히 간결해진 느낌은 있지만, 이제 약자로 표현된 필드의 값이 무엇이 의미하는지 쉽게 해석이 힘들어지는 문제가 생기네요. SQLAlchemy에서 제공하는 comment키워드에 redoc에서 사용했던 것과 같이 __doc__ 이용해 해당 키의 의미를 설명으로 넣어보겠습니다.request_type = Column(Enum(RequestEmailAuthType), comment=RequestEmailAuthType.__doc__, nullable=False)이제 생성된 스키마를 보면 html과 일반 text의 차이 때문에 생각했던 것과는 조금 다른 형태의 comment가 붙어있는 걸 볼 수 있습니다.`request_type` enum('J','R') NOT NULL COMMENT '\\n        1: 가입, 2: 비밀번호 초기화\\n        ',어떻게 본다면 별문제 아닌 것 같지만 만들다 만 것 같은 느낌의 결과는 용납할 수 없습니다. comment키워드에 일일이 주석을 달아주는 것도 좋은 방법이 될 수 있지만, 수작업이 많아진다는 건 그만큼 실수의 가능성이 커진다는 것과 동일한 의미이기 때문에 이것을 자동으로 만들어 줄 수 있는 무언가를 만들어야겠다는 생각을 하고 다음과 같이 만들어 보았습니다.class AnnotatedEnum(Enum):    def __new__(cls, *args, **kwargs):        tu = cls.__bases__        if len(tu) == 1:            # plain Enum            t = object            pass        else:            t = tu[0]        obj = t.__new__(cls)        obj._value_ = args[0]        return obj    def __init__(self, _, desc: str = None):        self.desc = desc    @classmethod    @property    def comment(cls):        items = cls.__members__.items()        docs = [f'{n}: {v.desc}' for n, v in items]        return ', '.join(docs)class RequestEmailAuthType(str, AnnotatedEnum, metaclass=AliasOnlyEnumMeta):    \"\"\"    1: 가입, 2: 비밀번호 초기화    \"\"\"    JOIN = '1', '회원가입'    RESET_PASSWORD = '2', '비밀번호 초기화'    J = '1'    R = '2'...request_type = Column(Enum(RequestEmailAuthType), comment=RequestEmailAuthType.comment, nullable=False)Python 열거형에 설명을 달아줄 수 있는 AnnotatedEnum을 만들어 하위 클래스로 RequestEmailAuthType을 생성했습니다. 이제 JOIN = '1', '회원가입'이런 식으로 Tuple 형태로 열거형의 값을 지정할 수 있고, 두 번째 인자는 desc에 자동으로 매핑 되도록 만들어주었고, 이런 식의 구조는 다음과 같은 장점을 가질 수 있습니다.  키, 값, 설명을 한 줄로 처리를 해서 보다 직관적으로 해석이 가능하다.  키가 새로 생기거나 삭제될 때 __doc__처리의 누락을 최소화할 수 있다.위 방식으로 만들어낸 스키마를 보면 아래와 같이 좀 더 깔끔한 설명을 남길 수 있습니다.`request_type` enum('J','R') NOT NULL COMMENT 'J: 회원가입, R: 비밀번호 초기화',redoc에서도 Annotation을 사용할 수 없을까?키와 값, 그리고 설명을 한 줄로 관리할 수 있게 만들었다면 이를 다른 곳에서도 활용할 수 있는 게 더 좋겠다는 생각이 들어 앞서 만든 AliasOnlyEnumMeta클래스를 생성할 때에 몇 가지 수정사항을 넣어 열거형의 __doc__을 자동으로 만들어 주는 기능을 넣어봤습니다.redoc은 html 태그를 지원하다 보니 키와 값에 대한 설명에 약간의 강조 처리도 함께 적용시켜보았죠.class AliasOnlyEnumMeta(EnumMeta):    def __new__(metacls, cls, bases, classdict, **kwargs):        obj = super(AliasOnlyEnumMeta, metacls).__new__(metacls, cls, bases, classdict, **kwargs)        members = obj.__members__        _desc_list = [            f'&lt;em&gt;{v.value}&lt;/em&gt; : &lt;strong&gt;{v.desc or \"-\"}&lt;/strong&gt;'            for _, v in members.items() if hasattr(v, 'desc')        ]        obj.__doc__ = ', '.join(_desc_list)        return obj위 코드를 이용해 redoc 문서를 보면 아래와 같이 강조되는 항목들이 생겨났습니다.처음보다 훨씬 보기 좋은 문서가 만들어졌습니다. 또한 열거형에 개발자가 서술한 __doc__을 그대로 유지하면서 메모리상의 __doc__만을 변경처리하여, 열거형의 Overview를 그대로 유지하면서 API / Database의 설명만을 자동으로 만들어 주는 형식이라 여러 가지로 효율성이 증대되는 방식을 만들어 낸 것 같습니다."
  },
  
  {
    "title": "FastAPI 유효성 검사",
    "url": "/posts/fast-api-validator/",
    "categories": "python, backend",
    "tags": "pydantic, validate, fastapi",
    "date": "2022-04-25 09:00:00 +0900",
    





    
    "snippet": "Request Body ValidateAPI 요청을 받으면 최소한으로 수행해야 하는 유효성 검사가 있습니다. 보안의 가장 기본인 SQL Injection 공격 이외에도 전달받은 데이터가 필요로 하는 최소한의 규칙 등이 있습니다.password를 예로 들자면 대소문자, 숫자, 특수문자를 포함해 최소 8에서 최대 20자리까지의 텍스트를 만족한다던가 혹은 ...",
    "content": "Request Body ValidateAPI 요청을 받으면 최소한으로 수행해야 하는 유효성 검사가 있습니다. 보안의 가장 기본인 SQL Injection 공격 이외에도 전달받은 데이터가 필요로 하는 최소한의 규칙 등이 있습니다.password를 예로 들자면 대소문자, 숫자, 특수문자를 포함해 최소 8에서 최대 20자리까지의 텍스트를 만족한다던가 혹은 전화번호는 숫자와 +- 등으로만 구성이 되어있는지 판단할 경우가 생기기 마련이죠.FastAPI 에서는 pydantic 이라는 Opensource 를 통해서 검증할 수가 있습니다.BaseModelpydantic 에서 제공하는 BaseModel과 Field를 이용하면 기본적인 유효성 검증을 손쉽게 처리할 수 있으며, 직접 유효성 검증을 하는 코드를 삽입하는 것 보다 훨씬 직관적이고 간편하게 사용할 수 있는 장점이 있습니다.from pydantic import BaseModelclass ModelIn(BaseModel):    password: str = Field(title='비밀번호', regex='^(?=.*[a-zA-Z])(?=.*[!@#$%^*+=-])(?=.*[0-9]).{8,20}$')    id: Optional[int] = Field(title='ID', default=None, ge=0)    class Config:        orm_mode = True위 예시는 password의 경우 대소문자와 숫자 그리고 특수문자를 포함한 8~20자리의 비밀번호를 허용, id는 null 혹은 0보다 큰 숫자만 허용한다는 유효성 검증의 예시입니다.@validatorField의 매개변수로 사용하는 gt, lt, min_length… 등만으로도 상당수의 유효성 검사를 만족할 수는 있지만, 사용자 정의 유효성 검사 및 개체 간의 복잡한 관계는 @ decorator를 통해 수행할 수 있습니다.class UserModel(BaseModel):    name: str = Field()    email: str = Field()    password: str = Field()    @validator('name')    def name_must_contain_space(cls, v):        if ' ' not in v:            raise ValueError('must contain a space')        return v위 코드는 변수 name에 대한 customized validator로 @validator({필드명}) 으로 처리 할 수 있습니다. 이때 필드명은 복수로 설정할 수 있으며 예시는 다음과 같습니다.@validator('email', 'password')def decrypt_fields(cls, raw):    ...    return@root_validator필드별 유효성 검증 외에도 요청받은 전체 모델의 유효성 검증을 해야 하는 경우도 필요합니다.예를 들면 복수의 리스트를 전달받았을 때 전체 항목에서 중복된 값이 존재하는지 여부를 판별하는데 쓰일 수도 있죠.class OrganizationModelIn(BaseModel):    industries: List[IndustryModelIn] = Field()    ...    @root_validator    def duplicate_not_allowed(cls, values):        industries = values.get('industries')        ids = [industry.id for industry in industries]        id_set = set(ids)        if len(id_set) != len(ids):            raise ValueError('industry id`s duplicate not allowed')        return valuesE2EE (End to End Encryption)패스워드나 기타 식별데이터는 HTTPS 프로토콜을 사용한다고 하더라도 암호화를 거쳐 종단 간에 통신이 이루어져야 합니다.위에서 password 필드에 정규식 ^(?=.*[a-zA-Z])(?=.*[!@#$%^*+=-])(?=.*[0-9]).{8,20}$을 넣었지만, 암호화된 필드 값으로는 애초에 정규식을 판별할 수 없다는 문제가 있으며,이에 pydantic에서는 validator decorator에 pre=키워드를 이용해 validate 함수를 먼저 호출한 후 필드에 적용된 정규식을 검사할 수 있도록 제공하고 있습니다.@validator('email', 'password', pre=True)def decrypt_fields(cls, raw):    from app.core.utils.crypto import rsa    try:        dec = rsa.dec(raw)    except Exception as e:        from app.core.errors.exceptions import CommonExceptions        raise CommonExceptions.InvalidEncryptionField(e)    return dec이렇게 validate 함수를 구현해 놓으면 1차로 decrypt_fields 함수를 먼저 실행, 복호화된 값을 토대로 다시 한번 Field에 적용된 validate 검사를 진행하게 됩니다.Validator Sequencevalidator decorator를 통해 유효성 검증을 하게 되면@validator가 먼저 실행되고, @root_validator가 나중에 실행 되게 됩니다. 각 validate 함수에 print를 찍어보면 아래와 같은 결과가 나옵니다@validator('email', 'password', pre=True)def decrypt_fields(cls, raw):    print(f'decrypt_fields')    ...    return dec@root_validatordef root_validator(cls, values):    print(f'root_validator')    return valuesdecrypt_fieldsdecrypt_fieldsroot_validator2%부족한 BaseModel요청을 받은 Body 데이터 중에 industries의 id가 데이터베이스에 있는지를 확인해야 새로 생성된 모델과의 제대로 된 관계 설정을 할 수가 있습니다.Django의 drf를 통해 유효성 검사를 경험해 보았던 제게는 Serializer 안에서 접근할 수 있는 ORM 객체와 관련 함수에 대한 아쉬움이 상당히 많이 남아async def some(session: Session = Depends(get_db)):    ...    return등과 같이 Depends함수를 통해 database session 을 가져오는 것처럼 BaseModel에서도 가져올 수 있지 않을까라는 생각을 하며 여러 가지 시도를 해보았습니다.하지만 pydantic에서 sqlalchemy를 하나의 커넥션으로 가져오는 방법에 드라마틱한 방식은 없다는 쪽으로 결론을 내고 Request Body의 유효성 검증이 모두 끝난 후 Depends를 통해 전체적으로 유효성 검증을 해 보았습니다.def model_in(model: OrganizationModelIn, database: Session = Depends(get_db)):    industries = model.industries    errors = []    from pydantic.error_wrappers import ErrorWrapper    for idx, industry in enumerate(industries):    if industry.id and 0 &lt; industry.id and not is_exists_industry(database, industry.id):        e = OrganizationExceptions.Join.UnDefinedIndustryId        errors.append(ErrorWrapper(e(industry.id), loc=('body', 'industries', idx, 'id')), )    if len(errors) != 0:        raise ValidationException(errors=errors, model=model)    return model, database@router.post()async def post_join(model_n_session=Depends(model_in)):    ...    returncrud에서 raise 처리를 하는 걸 고민해 보았으나, is_exists_industry함수는 industry.id에 1:1로 대응하는 게 낫겠다는 판단에 model_in이라고 하는 validate 함수를 만드는 방식으로 진행했습니다.위와 같이 실제 router에 제공되는 메서드에서 model_in이라는 함수를 통해 session을 하나의 커넥션으로 묶어 실제 데이터베이스와의 유효성 검증을 수행하도록 해보았습니다.  CRUD 단에서 데이터를 Insert 할 때에 실제 유효한 ID를 전달받은 것인지 확인해 볼 수도 있었지만, CRUD 각각의 함수에 대한 테스트 문제, 그리고, pydantic이 기본적으로 매개변수 유효성 검사를 통과하지 못할 때 내려주는 422 에러와 동일한 형태인{  \"detail\": [    {      \"loc\": [\"body\", \"industries\", 0],      \"msg\": \"정의 되지 않은 Industry 객체의 ID({id})가 입력되었습니다\",      \"type\": \"type_error\"    }  ]}처럼 내려 주고 싶다는 고집때문에 위와 같은 형태를 고안해 보았네요.이전 API와의 동질화아이메디신의 API는 FastAPI 외에도 SpringBoot를 사용하고 있습니다. API Host와 Response는 어쩔 수 없이 다른 형태로 사용한다고 하더라도 FrontEnd 쪽에서 처리하는 변수명 명명 규칙을 최대한 변화를 주지 않도록 하기 위해서 CamelCase 문법을 따르도록 수정을 해주어야 하는 상황이 발생하였습니다.pydantic Field에는 alias=를 통해 내부에서 사용되는 변수명과 request / response에서 사용되는 변수명을 다르게 할 수 있습니다. 예를 들면field_name = str = Field(alias='fieldName')위와 같이 FastAPI 내부에서는 python의 변수 형태인 field_name 을 사용할 수 있으면서 외부에서 사용되는 변수명은 fieldName으로 사용할 수 있는 건데요.모든 필드명에 이런 식으로 alias를 붙이는 건 효율성이 떨어진다는 문제점이 있어 pyhumps를 이용해 BaseModel을 상속받은 CamelModel을 사용해 보는 것으로 방향을 잡아 보았습니다.from humps import camelizeclass CamelModel(BaseModel):    class Config:        alias_generator = camelize        allow_population_by_field_name = True이제 BaseModel 대신 CamelModel을 impliment 하는 것으로 Feild(alias=)를 생략할 수가 있습니다.class IndustryModelIn(CamelModel):    id: Optional[PositiveInt] = Field(title='ID', default=None)    industry_title: Optional[str] = Field(title='산업 명', default=None)위 모델에 대응하는 Request Body는 다음과 같습니다{  \"id\": null,  \"industryTitle\": \"title\"}마치며밸리데이션을 처리하는 데 있어 어느 정도까지 깊게 구현하느냐는 API의 퍼포먼스와도 크게 영향이 있다 보니, 무턱대고 아무렇게나 살을 붙이기는 어려운 것 같습니다. 더욱이 표준을 중요시하는 제게 문서에서 추천하지 않는 디자인 패턴을 적용한다는 건 거부감이 상당히 많이 들기도 했지만, 어떻게든 응답의 형태를 맞추고 싶다는 욕망과의 싸움이 삽질을 한참이나 하게 된 이유가 된 것 같기도 하네요.실제로 Django/DRF를 사용하다 API의 퍼포먼스 개선을 위해 FastAPI로 환경을 구성하였으나, 그 장점을 살리지 못한다면 FastAPI로 갈아탄 이유가 없다는 생각을 많이 하게 된 시간을 가졌습니다."
  }
  
]

